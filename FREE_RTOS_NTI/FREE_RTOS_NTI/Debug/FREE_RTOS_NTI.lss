
FREE_RTOS_NTI.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000020e2  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000084  00800060  000020e2  00002176  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000068d  008000e4  008000e4  000021fa  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000021fa  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  0000222c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000560  00000000  00000000  00002268  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00005f4e  00000000  00000000  000027c8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001538  00000000  00000000  00008716  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00003602  00000000  00000000  00009c4e  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000f4c  00000000  00000000  0000d250  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001c67  00000000  00000000  0000e19c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00004c65  00000000  00000000  0000fe03  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000538  00000000  00000000  00014a68  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 63 02 	jmp	0x4c6	; 0x4c6 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 f8 0f 	jmp	0x1ff0	; 0x1ff0 <__vector_11>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 83 0e 	jmp	0x1d06	; 0x1d06 <__vector_16>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e2 ee       	ldi	r30, 0xE2	; 226
      68:	f0 e2       	ldi	r31, 0x20	; 32
      6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0
      70:	a4 3e       	cpi	r26, 0xE4	; 228
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
      76:	27 e0       	ldi	r18, 0x07	; 7
      78:	a4 ee       	ldi	r26, 0xE4	; 228
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a1 37       	cpi	r26, 0x71	; 113
      82:	b2 07       	cpc	r27, r18
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 37 0d 	call	0x1a6e	; 0x1a6e <main>
      8a:	0c 94 6f 10 	jmp	0x20de	; 0x20de <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
      92:	cf 93       	push	r28
      94:	df 93       	push	r29
      96:	ec 01       	movw	r28, r24
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
      98:	0e 94 1b 07 	call	0xe36	; 0xe36 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
      9c:	80 91 e4 00 	lds	r24, 0x00E4	; 0x8000e4 <__data_end>
      a0:	90 91 e5 00 	lds	r25, 0x00E5	; 0x8000e5 <__data_end+0x1>
      a4:	89 2b       	or	r24, r25
      a6:	31 f4       	brne	.+12     	; 0xb4 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
      a8:	89 ee       	ldi	r24, 0xE9	; 233
      aa:	90 e0       	ldi	r25, 0x00	; 0
      ac:	90 93 e5 00 	sts	0x00E5, r25	; 0x8000e5 <__data_end+0x1>
      b0:	80 93 e4 00 	sts	0x00E4, r24	; 0x8000e4 <__data_end>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
      b4:	20 91 e6 00 	lds	r18, 0x00E6	; 0x8000e6 <xNextFreeByte>
      b8:	30 91 e7 00 	lds	r19, 0x00E7	; 0x8000e7 <xNextFreeByte+0x1>
      bc:	c9 01       	movw	r24, r18
      be:	8c 0f       	add	r24, r28
      c0:	9d 1f       	adc	r25, r29
      c2:	8b 3d       	cpi	r24, 0xDB	; 219
      c4:	45 e0       	ldi	r20, 0x05	; 5
      c6:	94 07       	cpc	r25, r20
      c8:	70 f4       	brcc	.+28     	; 0xe6 <pvPortMalloc+0x54>
      ca:	28 17       	cp	r18, r24
      cc:	39 07       	cpc	r19, r25
      ce:	70 f4       	brcc	.+28     	; 0xec <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
      d0:	c0 91 e4 00 	lds	r28, 0x00E4	; 0x8000e4 <__data_end>
      d4:	d0 91 e5 00 	lds	r29, 0x00E5	; 0x8000e5 <__data_end+0x1>
      d8:	c2 0f       	add	r28, r18
      da:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
      dc:	90 93 e7 00 	sts	0x00E7, r25	; 0x8000e7 <xNextFreeByte+0x1>
      e0:	80 93 e6 00 	sts	0x00E6, r24	; 0x8000e6 <xNextFreeByte>
      e4:	05 c0       	rjmp	.+10     	; 0xf0 <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
      e6:	c0 e0       	ldi	r28, 0x00	; 0
      e8:	d0 e0       	ldi	r29, 0x00	; 0
      ea:	02 c0       	rjmp	.+4      	; 0xf0 <pvPortMalloc+0x5e>
      ec:	c0 e0       	ldi	r28, 0x00	; 0
      ee:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
      f0:	0e 94 db 07 	call	0xfb6	; 0xfb6 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
      f4:	ce 01       	movw	r24, r28
      f6:	df 91       	pop	r29
      f8:	cf 91       	pop	r28
      fa:	08 95       	ret

000000fc <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
      fc:	08 95       	ret

000000fe <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
      fe:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     100:	03 96       	adiw	r24, 0x03	; 3
     102:	92 83       	std	Z+2, r25	; 0x02
     104:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     106:	2f ef       	ldi	r18, 0xFF	; 255
     108:	3f ef       	ldi	r19, 0xFF	; 255
     10a:	34 83       	std	Z+4, r19	; 0x04
     10c:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     10e:	96 83       	std	Z+6, r25	; 0x06
     110:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     112:	90 87       	std	Z+8, r25	; 0x08
     114:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     116:	10 82       	st	Z, r1
     118:	08 95       	ret

0000011a <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
     11a:	fc 01       	movw	r30, r24
     11c:	11 86       	std	Z+9, r1	; 0x09
     11e:	10 86       	std	Z+8, r1	; 0x08
     120:	08 95       	ret

00000122 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     122:	cf 93       	push	r28
     124:	df 93       	push	r29
     126:	9c 01       	movw	r18, r24
     128:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     12a:	dc 01       	movw	r26, r24
     12c:	11 96       	adiw	r26, 0x01	; 1
     12e:	cd 91       	ld	r28, X+
     130:	dc 91       	ld	r29, X
     132:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     134:	d3 83       	std	Z+3, r29	; 0x03
     136:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     138:	8c 81       	ldd	r24, Y+4	; 0x04
     13a:	9d 81       	ldd	r25, Y+5	; 0x05
     13c:	95 83       	std	Z+5, r25	; 0x05
     13e:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     140:	8c 81       	ldd	r24, Y+4	; 0x04
     142:	9d 81       	ldd	r25, Y+5	; 0x05
     144:	dc 01       	movw	r26, r24
     146:	13 96       	adiw	r26, 0x03	; 3
     148:	7c 93       	st	X, r23
     14a:	6e 93       	st	-X, r22
     14c:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     14e:	7d 83       	std	Y+5, r23	; 0x05
     150:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
     152:	31 87       	std	Z+9, r19	; 0x09
     154:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     156:	f9 01       	movw	r30, r18
     158:	80 81       	ld	r24, Z
     15a:	8f 5f       	subi	r24, 0xFF	; 255
     15c:	80 83       	st	Z, r24
}
     15e:	df 91       	pop	r29
     160:	cf 91       	pop	r28
     162:	08 95       	ret

00000164 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     164:	cf 93       	push	r28
     166:	df 93       	push	r29
     168:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     16a:	48 81       	ld	r20, Y
     16c:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     16e:	4f 3f       	cpi	r20, 0xFF	; 255
     170:	2f ef       	ldi	r18, 0xFF	; 255
     172:	52 07       	cpc	r21, r18
     174:	21 f4       	brne	.+8      	; 0x17e <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     176:	fc 01       	movw	r30, r24
     178:	a7 81       	ldd	r26, Z+7	; 0x07
     17a:	b0 85       	ldd	r27, Z+8	; 0x08
     17c:	0d c0       	rjmp	.+26     	; 0x198 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
     17e:	dc 01       	movw	r26, r24
     180:	13 96       	adiw	r26, 0x03	; 3
     182:	01 c0       	rjmp	.+2      	; 0x186 <vListInsert+0x22>
     184:	df 01       	movw	r26, r30
     186:	12 96       	adiw	r26, 0x02	; 2
     188:	ed 91       	ld	r30, X+
     18a:	fc 91       	ld	r31, X
     18c:	13 97       	sbiw	r26, 0x03	; 3
     18e:	20 81       	ld	r18, Z
     190:	31 81       	ldd	r19, Z+1	; 0x01
     192:	42 17       	cp	r20, r18
     194:	53 07       	cpc	r21, r19
     196:	b0 f7       	brcc	.-20     	; 0x184 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     198:	12 96       	adiw	r26, 0x02	; 2
     19a:	ed 91       	ld	r30, X+
     19c:	fc 91       	ld	r31, X
     19e:	13 97       	sbiw	r26, 0x03	; 3
     1a0:	fb 83       	std	Y+3, r31	; 0x03
     1a2:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     1a4:	d5 83       	std	Z+5, r29	; 0x05
     1a6:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     1a8:	bd 83       	std	Y+5, r27	; 0x05
     1aa:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     1ac:	13 96       	adiw	r26, 0x03	; 3
     1ae:	dc 93       	st	X, r29
     1b0:	ce 93       	st	-X, r28
     1b2:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
     1b4:	99 87       	std	Y+9, r25	; 0x09
     1b6:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     1b8:	fc 01       	movw	r30, r24
     1ba:	20 81       	ld	r18, Z
     1bc:	2f 5f       	subi	r18, 0xFF	; 255
     1be:	20 83       	st	Z, r18
}
     1c0:	df 91       	pop	r29
     1c2:	cf 91       	pop	r28
     1c4:	08 95       	ret

000001c6 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     1c6:	cf 93       	push	r28
     1c8:	df 93       	push	r29
     1ca:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
     1cc:	a0 85       	ldd	r26, Z+8	; 0x08
     1ce:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     1d0:	c2 81       	ldd	r28, Z+2	; 0x02
     1d2:	d3 81       	ldd	r29, Z+3	; 0x03
     1d4:	84 81       	ldd	r24, Z+4	; 0x04
     1d6:	95 81       	ldd	r25, Z+5	; 0x05
     1d8:	9d 83       	std	Y+5, r25	; 0x05
     1da:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     1dc:	c4 81       	ldd	r28, Z+4	; 0x04
     1de:	d5 81       	ldd	r29, Z+5	; 0x05
     1e0:	82 81       	ldd	r24, Z+2	; 0x02
     1e2:	93 81       	ldd	r25, Z+3	; 0x03
     1e4:	9b 83       	std	Y+3, r25	; 0x03
     1e6:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     1e8:	11 96       	adiw	r26, 0x01	; 1
     1ea:	8d 91       	ld	r24, X+
     1ec:	9c 91       	ld	r25, X
     1ee:	12 97       	sbiw	r26, 0x02	; 2
     1f0:	e8 17       	cp	r30, r24
     1f2:	f9 07       	cpc	r31, r25
     1f4:	31 f4       	brne	.+12     	; 0x202 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     1f6:	84 81       	ldd	r24, Z+4	; 0x04
     1f8:	95 81       	ldd	r25, Z+5	; 0x05
     1fa:	12 96       	adiw	r26, 0x02	; 2
     1fc:	9c 93       	st	X, r25
     1fe:	8e 93       	st	-X, r24
     200:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
     202:	11 86       	std	Z+9, r1	; 0x09
     204:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     206:	8c 91       	ld	r24, X
     208:	81 50       	subi	r24, 0x01	; 1
     20a:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
     20c:	8c 91       	ld	r24, X
}
     20e:	df 91       	pop	r29
     210:	cf 91       	pop	r28
     212:	08 95       	ret

00000214 <prvSetupTimerInterrupt>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     214:	1b bc       	out	0x2b, r1	; 43
     216:	8c e7       	ldi	r24, 0x7C	; 124
     218:	8a bd       	out	0x2a, r24	; 42
     21a:	8b e0       	ldi	r24, 0x0B	; 11
     21c:	8e bd       	out	0x2e, r24	; 46
     21e:	89 b7       	in	r24, 0x39	; 57
     220:	80 61       	ori	r24, 0x10	; 16
     222:	89 bf       	out	0x39, r24	; 57
     224:	08 95       	ret

00000226 <pxPortInitialiseStack>:
     226:	31 e1       	ldi	r19, 0x11	; 17
     228:	fc 01       	movw	r30, r24
     22a:	30 83       	st	Z, r19
     22c:	31 97       	sbiw	r30, 0x01	; 1
     22e:	22 e2       	ldi	r18, 0x22	; 34
     230:	20 83       	st	Z, r18
     232:	31 97       	sbiw	r30, 0x01	; 1
     234:	a3 e3       	ldi	r26, 0x33	; 51
     236:	a0 83       	st	Z, r26
     238:	31 97       	sbiw	r30, 0x01	; 1
     23a:	60 83       	st	Z, r22
     23c:	31 97       	sbiw	r30, 0x01	; 1
     23e:	70 83       	st	Z, r23
     240:	31 97       	sbiw	r30, 0x01	; 1
     242:	10 82       	st	Z, r1
     244:	31 97       	sbiw	r30, 0x01	; 1
     246:	60 e8       	ldi	r22, 0x80	; 128
     248:	60 83       	st	Z, r22
     24a:	31 97       	sbiw	r30, 0x01	; 1
     24c:	10 82       	st	Z, r1
     24e:	31 97       	sbiw	r30, 0x01	; 1
     250:	62 e0       	ldi	r22, 0x02	; 2
     252:	60 83       	st	Z, r22
     254:	31 97       	sbiw	r30, 0x01	; 1
     256:	63 e0       	ldi	r22, 0x03	; 3
     258:	60 83       	st	Z, r22
     25a:	31 97       	sbiw	r30, 0x01	; 1
     25c:	64 e0       	ldi	r22, 0x04	; 4
     25e:	60 83       	st	Z, r22
     260:	31 97       	sbiw	r30, 0x01	; 1
     262:	65 e0       	ldi	r22, 0x05	; 5
     264:	60 83       	st	Z, r22
     266:	31 97       	sbiw	r30, 0x01	; 1
     268:	66 e0       	ldi	r22, 0x06	; 6
     26a:	60 83       	st	Z, r22
     26c:	31 97       	sbiw	r30, 0x01	; 1
     26e:	67 e0       	ldi	r22, 0x07	; 7
     270:	60 83       	st	Z, r22
     272:	31 97       	sbiw	r30, 0x01	; 1
     274:	68 e0       	ldi	r22, 0x08	; 8
     276:	60 83       	st	Z, r22
     278:	31 97       	sbiw	r30, 0x01	; 1
     27a:	69 e0       	ldi	r22, 0x09	; 9
     27c:	60 83       	st	Z, r22
     27e:	31 97       	sbiw	r30, 0x01	; 1
     280:	60 e1       	ldi	r22, 0x10	; 16
     282:	60 83       	st	Z, r22
     284:	31 97       	sbiw	r30, 0x01	; 1
     286:	30 83       	st	Z, r19
     288:	31 97       	sbiw	r30, 0x01	; 1
     28a:	32 e1       	ldi	r19, 0x12	; 18
     28c:	30 83       	st	Z, r19
     28e:	31 97       	sbiw	r30, 0x01	; 1
     290:	33 e1       	ldi	r19, 0x13	; 19
     292:	30 83       	st	Z, r19
     294:	31 97       	sbiw	r30, 0x01	; 1
     296:	34 e1       	ldi	r19, 0x14	; 20
     298:	30 83       	st	Z, r19
     29a:	31 97       	sbiw	r30, 0x01	; 1
     29c:	35 e1       	ldi	r19, 0x15	; 21
     29e:	30 83       	st	Z, r19
     2a0:	31 97       	sbiw	r30, 0x01	; 1
     2a2:	36 e1       	ldi	r19, 0x16	; 22
     2a4:	30 83       	st	Z, r19
     2a6:	31 97       	sbiw	r30, 0x01	; 1
     2a8:	37 e1       	ldi	r19, 0x17	; 23
     2aa:	30 83       	st	Z, r19
     2ac:	31 97       	sbiw	r30, 0x01	; 1
     2ae:	38 e1       	ldi	r19, 0x18	; 24
     2b0:	30 83       	st	Z, r19
     2b2:	31 97       	sbiw	r30, 0x01	; 1
     2b4:	39 e1       	ldi	r19, 0x19	; 25
     2b6:	30 83       	st	Z, r19
     2b8:	31 97       	sbiw	r30, 0x01	; 1
     2ba:	30 e2       	ldi	r19, 0x20	; 32
     2bc:	30 83       	st	Z, r19
     2be:	31 97       	sbiw	r30, 0x01	; 1
     2c0:	31 e2       	ldi	r19, 0x21	; 33
     2c2:	30 83       	st	Z, r19
     2c4:	31 97       	sbiw	r30, 0x01	; 1
     2c6:	20 83       	st	Z, r18
     2c8:	31 97       	sbiw	r30, 0x01	; 1
     2ca:	23 e2       	ldi	r18, 0x23	; 35
     2cc:	20 83       	st	Z, r18
     2ce:	31 97       	sbiw	r30, 0x01	; 1
     2d0:	40 83       	st	Z, r20
     2d2:	31 97       	sbiw	r30, 0x01	; 1
     2d4:	50 83       	st	Z, r21
     2d6:	31 97       	sbiw	r30, 0x01	; 1
     2d8:	26 e2       	ldi	r18, 0x26	; 38
     2da:	20 83       	st	Z, r18
     2dc:	31 97       	sbiw	r30, 0x01	; 1
     2de:	27 e2       	ldi	r18, 0x27	; 39
     2e0:	20 83       	st	Z, r18
     2e2:	31 97       	sbiw	r30, 0x01	; 1
     2e4:	28 e2       	ldi	r18, 0x28	; 40
     2e6:	20 83       	st	Z, r18
     2e8:	31 97       	sbiw	r30, 0x01	; 1
     2ea:	29 e2       	ldi	r18, 0x29	; 41
     2ec:	20 83       	st	Z, r18
     2ee:	31 97       	sbiw	r30, 0x01	; 1
     2f0:	20 e3       	ldi	r18, 0x30	; 48
     2f2:	20 83       	st	Z, r18
     2f4:	31 97       	sbiw	r30, 0x01	; 1
     2f6:	21 e3       	ldi	r18, 0x31	; 49
     2f8:	20 83       	st	Z, r18
     2fa:	86 97       	sbiw	r24, 0x26	; 38
     2fc:	08 95       	ret

000002fe <xPortStartScheduler>:
     2fe:	0e 94 0a 01 	call	0x214	; 0x214 <prvSetupTimerInterrupt>
     302:	a0 91 4c 07 	lds	r26, 0x074C	; 0x80074c <pxCurrentTCB>
     306:	b0 91 4d 07 	lds	r27, 0x074D	; 0x80074d <pxCurrentTCB+0x1>
     30a:	cd 91       	ld	r28, X+
     30c:	cd bf       	out	0x3d, r28	; 61
     30e:	dd 91       	ld	r29, X+
     310:	de bf       	out	0x3e, r29	; 62
     312:	ff 91       	pop	r31
     314:	ef 91       	pop	r30
     316:	df 91       	pop	r29
     318:	cf 91       	pop	r28
     31a:	bf 91       	pop	r27
     31c:	af 91       	pop	r26
     31e:	9f 91       	pop	r25
     320:	8f 91       	pop	r24
     322:	7f 91       	pop	r23
     324:	6f 91       	pop	r22
     326:	5f 91       	pop	r21
     328:	4f 91       	pop	r20
     32a:	3f 91       	pop	r19
     32c:	2f 91       	pop	r18
     32e:	1f 91       	pop	r17
     330:	0f 91       	pop	r16
     332:	ff 90       	pop	r15
     334:	ef 90       	pop	r14
     336:	df 90       	pop	r13
     338:	cf 90       	pop	r12
     33a:	bf 90       	pop	r11
     33c:	af 90       	pop	r10
     33e:	9f 90       	pop	r9
     340:	8f 90       	pop	r8
     342:	7f 90       	pop	r7
     344:	6f 90       	pop	r6
     346:	5f 90       	pop	r5
     348:	4f 90       	pop	r4
     34a:	3f 90       	pop	r3
     34c:	2f 90       	pop	r2
     34e:	1f 90       	pop	r1
     350:	0f 90       	pop	r0
     352:	0f be       	out	0x3f, r0	; 63
     354:	0f 90       	pop	r0
     356:	08 95       	ret
     358:	81 e0       	ldi	r24, 0x01	; 1
     35a:	08 95       	ret

0000035c <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     35c:	0f 92       	push	r0
     35e:	0f b6       	in	r0, 0x3f	; 63
     360:	f8 94       	cli
     362:	0f 92       	push	r0
     364:	1f 92       	push	r1
     366:	11 24       	eor	r1, r1
     368:	2f 92       	push	r2
     36a:	3f 92       	push	r3
     36c:	4f 92       	push	r4
     36e:	5f 92       	push	r5
     370:	6f 92       	push	r6
     372:	7f 92       	push	r7
     374:	8f 92       	push	r8
     376:	9f 92       	push	r9
     378:	af 92       	push	r10
     37a:	bf 92       	push	r11
     37c:	cf 92       	push	r12
     37e:	df 92       	push	r13
     380:	ef 92       	push	r14
     382:	ff 92       	push	r15
     384:	0f 93       	push	r16
     386:	1f 93       	push	r17
     388:	2f 93       	push	r18
     38a:	3f 93       	push	r19
     38c:	4f 93       	push	r20
     38e:	5f 93       	push	r21
     390:	6f 93       	push	r22
     392:	7f 93       	push	r23
     394:	8f 93       	push	r24
     396:	9f 93       	push	r25
     398:	af 93       	push	r26
     39a:	bf 93       	push	r27
     39c:	cf 93       	push	r28
     39e:	df 93       	push	r29
     3a0:	ef 93       	push	r30
     3a2:	ff 93       	push	r31
     3a4:	a0 91 4c 07 	lds	r26, 0x074C	; 0x80074c <pxCurrentTCB>
     3a8:	b0 91 4d 07 	lds	r27, 0x074D	; 0x80074d <pxCurrentTCB+0x1>
     3ac:	0d b6       	in	r0, 0x3d	; 61
     3ae:	0d 92       	st	X+, r0
     3b0:	0e b6       	in	r0, 0x3e	; 62
     3b2:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     3b4:	0e 94 63 08 	call	0x10c6	; 0x10c6 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     3b8:	a0 91 4c 07 	lds	r26, 0x074C	; 0x80074c <pxCurrentTCB>
     3bc:	b0 91 4d 07 	lds	r27, 0x074D	; 0x80074d <pxCurrentTCB+0x1>
     3c0:	cd 91       	ld	r28, X+
     3c2:	cd bf       	out	0x3d, r28	; 61
     3c4:	dd 91       	ld	r29, X+
     3c6:	de bf       	out	0x3e, r29	; 62
     3c8:	ff 91       	pop	r31
     3ca:	ef 91       	pop	r30
     3cc:	df 91       	pop	r29
     3ce:	cf 91       	pop	r28
     3d0:	bf 91       	pop	r27
     3d2:	af 91       	pop	r26
     3d4:	9f 91       	pop	r25
     3d6:	8f 91       	pop	r24
     3d8:	7f 91       	pop	r23
     3da:	6f 91       	pop	r22
     3dc:	5f 91       	pop	r21
     3de:	4f 91       	pop	r20
     3e0:	3f 91       	pop	r19
     3e2:	2f 91       	pop	r18
     3e4:	1f 91       	pop	r17
     3e6:	0f 91       	pop	r16
     3e8:	ff 90       	pop	r15
     3ea:	ef 90       	pop	r14
     3ec:	df 90       	pop	r13
     3ee:	cf 90       	pop	r12
     3f0:	bf 90       	pop	r11
     3f2:	af 90       	pop	r10
     3f4:	9f 90       	pop	r9
     3f6:	8f 90       	pop	r8
     3f8:	7f 90       	pop	r7
     3fa:	6f 90       	pop	r6
     3fc:	5f 90       	pop	r5
     3fe:	4f 90       	pop	r4
     400:	3f 90       	pop	r3
     402:	2f 90       	pop	r2
     404:	1f 90       	pop	r1
     406:	0f 90       	pop	r0
     408:	0f be       	out	0x3f, r0	; 63
     40a:	0f 90       	pop	r0

	asm volatile ( "ret" );
     40c:	08 95       	ret

0000040e <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     40e:	0f 92       	push	r0
     410:	0f b6       	in	r0, 0x3f	; 63
     412:	f8 94       	cli
     414:	0f 92       	push	r0
     416:	1f 92       	push	r1
     418:	11 24       	eor	r1, r1
     41a:	2f 92       	push	r2
     41c:	3f 92       	push	r3
     41e:	4f 92       	push	r4
     420:	5f 92       	push	r5
     422:	6f 92       	push	r6
     424:	7f 92       	push	r7
     426:	8f 92       	push	r8
     428:	9f 92       	push	r9
     42a:	af 92       	push	r10
     42c:	bf 92       	push	r11
     42e:	cf 92       	push	r12
     430:	df 92       	push	r13
     432:	ef 92       	push	r14
     434:	ff 92       	push	r15
     436:	0f 93       	push	r16
     438:	1f 93       	push	r17
     43a:	2f 93       	push	r18
     43c:	3f 93       	push	r19
     43e:	4f 93       	push	r20
     440:	5f 93       	push	r21
     442:	6f 93       	push	r22
     444:	7f 93       	push	r23
     446:	8f 93       	push	r24
     448:	9f 93       	push	r25
     44a:	af 93       	push	r26
     44c:	bf 93       	push	r27
     44e:	cf 93       	push	r28
     450:	df 93       	push	r29
     452:	ef 93       	push	r30
     454:	ff 93       	push	r31
     456:	a0 91 4c 07 	lds	r26, 0x074C	; 0x80074c <pxCurrentTCB>
     45a:	b0 91 4d 07 	lds	r27, 0x074D	; 0x80074d <pxCurrentTCB+0x1>
     45e:	0d b6       	in	r0, 0x3d	; 61
     460:	0d 92       	st	X+, r0
     462:	0e b6       	in	r0, 0x3e	; 62
     464:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     466:	0e 94 21 07 	call	0xe42	; 0xe42 <xTaskIncrementTick>
     46a:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     46c:	0e 94 63 08 	call	0x10c6	; 0x10c6 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     470:	a0 91 4c 07 	lds	r26, 0x074C	; 0x80074c <pxCurrentTCB>
     474:	b0 91 4d 07 	lds	r27, 0x074D	; 0x80074d <pxCurrentTCB+0x1>
     478:	cd 91       	ld	r28, X+
     47a:	cd bf       	out	0x3d, r28	; 61
     47c:	dd 91       	ld	r29, X+
     47e:	de bf       	out	0x3e, r29	; 62
     480:	ff 91       	pop	r31
     482:	ef 91       	pop	r30
     484:	df 91       	pop	r29
     486:	cf 91       	pop	r28
     488:	bf 91       	pop	r27
     48a:	af 91       	pop	r26
     48c:	9f 91       	pop	r25
     48e:	8f 91       	pop	r24
     490:	7f 91       	pop	r23
     492:	6f 91       	pop	r22
     494:	5f 91       	pop	r21
     496:	4f 91       	pop	r20
     498:	3f 91       	pop	r19
     49a:	2f 91       	pop	r18
     49c:	1f 91       	pop	r17
     49e:	0f 91       	pop	r16
     4a0:	ff 90       	pop	r15
     4a2:	ef 90       	pop	r14
     4a4:	df 90       	pop	r13
     4a6:	cf 90       	pop	r12
     4a8:	bf 90       	pop	r11
     4aa:	af 90       	pop	r10
     4ac:	9f 90       	pop	r9
     4ae:	8f 90       	pop	r8
     4b0:	7f 90       	pop	r7
     4b2:	6f 90       	pop	r6
     4b4:	5f 90       	pop	r5
     4b6:	4f 90       	pop	r4
     4b8:	3f 90       	pop	r3
     4ba:	2f 90       	pop	r2
     4bc:	1f 90       	pop	r1
     4be:	0f 90       	pop	r0
     4c0:	0f be       	out	0x3f, r0	; 63
     4c2:	0f 90       	pop	r0

	asm volatile ( "ret" );
     4c4:	08 95       	ret

000004c6 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
     4c6:	0e 94 07 02 	call	0x40e	; 0x40e <vPortYieldFromTick>
		asm volatile ( "reti" );
     4ca:	18 95       	reti

000004cc <prvGetDisinheritPriorityAfterTimeout>:
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
     4cc:	dc 01       	movw	r26, r24
     4ce:	51 96       	adiw	r26, 0x11	; 17
     4d0:	2c 91       	ld	r18, X
     4d2:	51 97       	sbiw	r26, 0x11	; 17
     4d4:	22 23       	and	r18, r18
     4d6:	41 f0       	breq	.+16     	; 0x4e8 <prvGetDisinheritPriorityAfterTimeout+0x1c>
     4d8:	56 96       	adiw	r26, 0x16	; 22
     4da:	ed 91       	ld	r30, X+
     4dc:	fc 91       	ld	r31, X
     4de:	57 97       	sbiw	r26, 0x17	; 23
     4e0:	90 81       	ld	r25, Z
     4e2:	88 e0       	ldi	r24, 0x08	; 8
     4e4:	89 1b       	sub	r24, r25
     4e6:	08 95       	ret
     4e8:	80 e0       	ldi	r24, 0x00	; 0
     4ea:	08 95       	ret

000004ec <prvIsQueueEmpty>:
     4ec:	0f b6       	in	r0, 0x3f	; 63
     4ee:	f8 94       	cli
     4f0:	0f 92       	push	r0
     4f2:	fc 01       	movw	r30, r24
     4f4:	82 8d       	ldd	r24, Z+26	; 0x1a
     4f6:	81 11       	cpse	r24, r1
     4f8:	02 c0       	rjmp	.+4      	; 0x4fe <prvIsQueueEmpty+0x12>
     4fa:	81 e0       	ldi	r24, 0x01	; 1
     4fc:	01 c0       	rjmp	.+2      	; 0x500 <prvIsQueueEmpty+0x14>
     4fe:	80 e0       	ldi	r24, 0x00	; 0
     500:	0f 90       	pop	r0
     502:	0f be       	out	0x3f, r0	; 63
     504:	08 95       	ret

00000506 <prvIsQueueFull>:
     506:	0f b6       	in	r0, 0x3f	; 63
     508:	f8 94       	cli
     50a:	0f 92       	push	r0
     50c:	fc 01       	movw	r30, r24
     50e:	22 8d       	ldd	r18, Z+26	; 0x1a
     510:	83 8d       	ldd	r24, Z+27	; 0x1b
     512:	28 13       	cpse	r18, r24
     514:	02 c0       	rjmp	.+4      	; 0x51a <prvIsQueueFull+0x14>
     516:	81 e0       	ldi	r24, 0x01	; 1
     518:	01 c0       	rjmp	.+2      	; 0x51c <prvIsQueueFull+0x16>
     51a:	80 e0       	ldi	r24, 0x00	; 0
     51c:	0f 90       	pop	r0
     51e:	0f be       	out	0x3f, r0	; 63
     520:	08 95       	ret

00000522 <prvCopyDataToQueue>:
     522:	0f 93       	push	r16
     524:	1f 93       	push	r17
     526:	cf 93       	push	r28
     528:	df 93       	push	r29
     52a:	ec 01       	movw	r28, r24
     52c:	04 2f       	mov	r16, r20
     52e:	1a 8d       	ldd	r17, Y+26	; 0x1a
     530:	4c 8d       	ldd	r20, Y+28	; 0x1c
     532:	41 11       	cpse	r20, r1
     534:	0c c0       	rjmp	.+24     	; 0x54e <prvCopyDataToQueue+0x2c>
     536:	88 81       	ld	r24, Y
     538:	99 81       	ldd	r25, Y+1	; 0x01
     53a:	89 2b       	or	r24, r25
     53c:	09 f0       	breq	.+2      	; 0x540 <prvCopyDataToQueue+0x1e>
     53e:	42 c0       	rjmp	.+132    	; 0x5c4 <prvCopyDataToQueue+0xa2>
     540:	8c 81       	ldd	r24, Y+4	; 0x04
     542:	9d 81       	ldd	r25, Y+5	; 0x05
     544:	0e 94 ce 09 	call	0x139c	; 0x139c <xTaskPriorityDisinherit>
     548:	1d 82       	std	Y+5, r1	; 0x05
     54a:	1c 82       	std	Y+4, r1	; 0x04
     54c:	42 c0       	rjmp	.+132    	; 0x5d2 <prvCopyDataToQueue+0xb0>
     54e:	01 11       	cpse	r16, r1
     550:	17 c0       	rjmp	.+46     	; 0x580 <prvCopyDataToQueue+0x5e>
     552:	50 e0       	ldi	r21, 0x00	; 0
     554:	8a 81       	ldd	r24, Y+2	; 0x02
     556:	9b 81       	ldd	r25, Y+3	; 0x03
     558:	0e 94 66 10 	call	0x20cc	; 0x20cc <memcpy>
     55c:	2c 8d       	ldd	r18, Y+28	; 0x1c
     55e:	8a 81       	ldd	r24, Y+2	; 0x02
     560:	9b 81       	ldd	r25, Y+3	; 0x03
     562:	82 0f       	add	r24, r18
     564:	91 1d       	adc	r25, r1
     566:	9b 83       	std	Y+3, r25	; 0x03
     568:	8a 83       	std	Y+2, r24	; 0x02
     56a:	2c 81       	ldd	r18, Y+4	; 0x04
     56c:	3d 81       	ldd	r19, Y+5	; 0x05
     56e:	82 17       	cp	r24, r18
     570:	93 07       	cpc	r25, r19
     572:	50 f1       	brcs	.+84     	; 0x5c8 <prvCopyDataToQueue+0xa6>
     574:	88 81       	ld	r24, Y
     576:	99 81       	ldd	r25, Y+1	; 0x01
     578:	9b 83       	std	Y+3, r25	; 0x03
     57a:	8a 83       	std	Y+2, r24	; 0x02
     57c:	80 e0       	ldi	r24, 0x00	; 0
     57e:	29 c0       	rjmp	.+82     	; 0x5d2 <prvCopyDataToQueue+0xb0>
     580:	50 e0       	ldi	r21, 0x00	; 0
     582:	8e 81       	ldd	r24, Y+6	; 0x06
     584:	9f 81       	ldd	r25, Y+7	; 0x07
     586:	0e 94 66 10 	call	0x20cc	; 0x20cc <memcpy>
     58a:	8c 8d       	ldd	r24, Y+28	; 0x1c
     58c:	90 e0       	ldi	r25, 0x00	; 0
     58e:	91 95       	neg	r25
     590:	81 95       	neg	r24
     592:	91 09       	sbc	r25, r1
     594:	2e 81       	ldd	r18, Y+6	; 0x06
     596:	3f 81       	ldd	r19, Y+7	; 0x07
     598:	28 0f       	add	r18, r24
     59a:	39 1f       	adc	r19, r25
     59c:	3f 83       	std	Y+7, r19	; 0x07
     59e:	2e 83       	std	Y+6, r18	; 0x06
     5a0:	48 81       	ld	r20, Y
     5a2:	59 81       	ldd	r21, Y+1	; 0x01
     5a4:	24 17       	cp	r18, r20
     5a6:	35 07       	cpc	r19, r21
     5a8:	30 f4       	brcc	.+12     	; 0x5b6 <prvCopyDataToQueue+0x94>
     5aa:	2c 81       	ldd	r18, Y+4	; 0x04
     5ac:	3d 81       	ldd	r19, Y+5	; 0x05
     5ae:	82 0f       	add	r24, r18
     5b0:	93 1f       	adc	r25, r19
     5b2:	9f 83       	std	Y+7, r25	; 0x07
     5b4:	8e 83       	std	Y+6, r24	; 0x06
     5b6:	02 30       	cpi	r16, 0x02	; 2
     5b8:	49 f4       	brne	.+18     	; 0x5cc <prvCopyDataToQueue+0xaa>
     5ba:	11 23       	and	r17, r17
     5bc:	49 f0       	breq	.+18     	; 0x5d0 <prvCopyDataToQueue+0xae>
     5be:	11 50       	subi	r17, 0x01	; 1
     5c0:	80 e0       	ldi	r24, 0x00	; 0
     5c2:	07 c0       	rjmp	.+14     	; 0x5d2 <prvCopyDataToQueue+0xb0>
     5c4:	80 e0       	ldi	r24, 0x00	; 0
     5c6:	05 c0       	rjmp	.+10     	; 0x5d2 <prvCopyDataToQueue+0xb0>
     5c8:	80 e0       	ldi	r24, 0x00	; 0
     5ca:	03 c0       	rjmp	.+6      	; 0x5d2 <prvCopyDataToQueue+0xb0>
     5cc:	80 e0       	ldi	r24, 0x00	; 0
     5ce:	01 c0       	rjmp	.+2      	; 0x5d2 <prvCopyDataToQueue+0xb0>
     5d0:	80 e0       	ldi	r24, 0x00	; 0
     5d2:	1f 5f       	subi	r17, 0xFF	; 255
     5d4:	1a 8f       	std	Y+26, r17	; 0x1a
     5d6:	df 91       	pop	r29
     5d8:	cf 91       	pop	r28
     5da:	1f 91       	pop	r17
     5dc:	0f 91       	pop	r16
     5de:	08 95       	ret

000005e0 <prvUnlockQueue>:
     5e0:	1f 93       	push	r17
     5e2:	cf 93       	push	r28
     5e4:	df 93       	push	r29
     5e6:	ec 01       	movw	r28, r24
     5e8:	0f b6       	in	r0, 0x3f	; 63
     5ea:	f8 94       	cli
     5ec:	0f 92       	push	r0
     5ee:	1e 8d       	ldd	r17, Y+30	; 0x1e
     5f0:	0b c0       	rjmp	.+22     	; 0x608 <prvUnlockQueue+0x28>
     5f2:	89 89       	ldd	r24, Y+17	; 0x11
     5f4:	88 23       	and	r24, r24
     5f6:	51 f0       	breq	.+20     	; 0x60c <prvUnlockQueue+0x2c>
     5f8:	ce 01       	movw	r24, r28
     5fa:	41 96       	adiw	r24, 0x11	; 17
     5fc:	0e 94 c9 08 	call	0x1192	; 0x1192 <xTaskRemoveFromEventList>
     600:	81 11       	cpse	r24, r1
     602:	0e 94 58 09 	call	0x12b0	; 0x12b0 <vTaskMissedYield>
     606:	11 50       	subi	r17, 0x01	; 1
     608:	11 16       	cp	r1, r17
     60a:	9c f3       	brlt	.-26     	; 0x5f2 <prvUnlockQueue+0x12>
     60c:	8f ef       	ldi	r24, 0xFF	; 255
     60e:	8e 8f       	std	Y+30, r24	; 0x1e
     610:	0f 90       	pop	r0
     612:	0f be       	out	0x3f, r0	; 63
     614:	0f b6       	in	r0, 0x3f	; 63
     616:	f8 94       	cli
     618:	0f 92       	push	r0
     61a:	1d 8d       	ldd	r17, Y+29	; 0x1d
     61c:	0b c0       	rjmp	.+22     	; 0x634 <prvUnlockQueue+0x54>
     61e:	88 85       	ldd	r24, Y+8	; 0x08
     620:	88 23       	and	r24, r24
     622:	51 f0       	breq	.+20     	; 0x638 <prvUnlockQueue+0x58>
     624:	ce 01       	movw	r24, r28
     626:	08 96       	adiw	r24, 0x08	; 8
     628:	0e 94 c9 08 	call	0x1192	; 0x1192 <xTaskRemoveFromEventList>
     62c:	81 11       	cpse	r24, r1
     62e:	0e 94 58 09 	call	0x12b0	; 0x12b0 <vTaskMissedYield>
     632:	11 50       	subi	r17, 0x01	; 1
     634:	11 16       	cp	r1, r17
     636:	9c f3       	brlt	.-26     	; 0x61e <prvUnlockQueue+0x3e>
     638:	8f ef       	ldi	r24, 0xFF	; 255
     63a:	8d 8f       	std	Y+29, r24	; 0x1d
     63c:	0f 90       	pop	r0
     63e:	0f be       	out	0x3f, r0	; 63
     640:	df 91       	pop	r29
     642:	cf 91       	pop	r28
     644:	1f 91       	pop	r17
     646:	08 95       	ret

00000648 <xQueueGenericReset>:
     648:	cf 93       	push	r28
     64a:	df 93       	push	r29
     64c:	ec 01       	movw	r28, r24
     64e:	0f b6       	in	r0, 0x3f	; 63
     650:	f8 94       	cli
     652:	0f 92       	push	r0
     654:	e8 81       	ld	r30, Y
     656:	f9 81       	ldd	r31, Y+1	; 0x01
     658:	8b 8d       	ldd	r24, Y+27	; 0x1b
     65a:	2c 8d       	ldd	r18, Y+28	; 0x1c
     65c:	90 e0       	ldi	r25, 0x00	; 0
     65e:	30 e0       	ldi	r19, 0x00	; 0
     660:	82 9f       	mul	r24, r18
     662:	a0 01       	movw	r20, r0
     664:	83 9f       	mul	r24, r19
     666:	50 0d       	add	r21, r0
     668:	92 9f       	mul	r25, r18
     66a:	50 0d       	add	r21, r0
     66c:	11 24       	eor	r1, r1
     66e:	4e 0f       	add	r20, r30
     670:	5f 1f       	adc	r21, r31
     672:	5d 83       	std	Y+5, r21	; 0x05
     674:	4c 83       	std	Y+4, r20	; 0x04
     676:	1a 8e       	std	Y+26, r1	; 0x1a
     678:	fb 83       	std	Y+3, r31	; 0x03
     67a:	ea 83       	std	Y+2, r30	; 0x02
     67c:	01 97       	sbiw	r24, 0x01	; 1
     67e:	28 9f       	mul	r18, r24
     680:	a0 01       	movw	r20, r0
     682:	29 9f       	mul	r18, r25
     684:	50 0d       	add	r21, r0
     686:	38 9f       	mul	r19, r24
     688:	50 0d       	add	r21, r0
     68a:	11 24       	eor	r1, r1
     68c:	cf 01       	movw	r24, r30
     68e:	84 0f       	add	r24, r20
     690:	95 1f       	adc	r25, r21
     692:	9f 83       	std	Y+7, r25	; 0x07
     694:	8e 83       	std	Y+6, r24	; 0x06
     696:	8f ef       	ldi	r24, 0xFF	; 255
     698:	8d 8f       	std	Y+29, r24	; 0x1d
     69a:	8e 8f       	std	Y+30, r24	; 0x1e
     69c:	61 11       	cpse	r22, r1
     69e:	0c c0       	rjmp	.+24     	; 0x6b8 <xQueueGenericReset+0x70>
     6a0:	88 85       	ldd	r24, Y+8	; 0x08
     6a2:	88 23       	and	r24, r24
     6a4:	89 f0       	breq	.+34     	; 0x6c8 <xQueueGenericReset+0x80>
     6a6:	ce 01       	movw	r24, r28
     6a8:	08 96       	adiw	r24, 0x08	; 8
     6aa:	0e 94 c9 08 	call	0x1192	; 0x1192 <xTaskRemoveFromEventList>
     6ae:	88 23       	and	r24, r24
     6b0:	59 f0       	breq	.+22     	; 0x6c8 <xQueueGenericReset+0x80>
     6b2:	0e 94 ae 01 	call	0x35c	; 0x35c <vPortYield>
     6b6:	08 c0       	rjmp	.+16     	; 0x6c8 <xQueueGenericReset+0x80>
     6b8:	ce 01       	movw	r24, r28
     6ba:	08 96       	adiw	r24, 0x08	; 8
     6bc:	0e 94 7f 00 	call	0xfe	; 0xfe <vListInitialise>
     6c0:	ce 01       	movw	r24, r28
     6c2:	41 96       	adiw	r24, 0x11	; 17
     6c4:	0e 94 7f 00 	call	0xfe	; 0xfe <vListInitialise>
     6c8:	0f 90       	pop	r0
     6ca:	0f be       	out	0x3f, r0	; 63
     6cc:	81 e0       	ldi	r24, 0x01	; 1
     6ce:	df 91       	pop	r29
     6d0:	cf 91       	pop	r28
     6d2:	08 95       	ret

000006d4 <prvInitialiseNewQueue>:
     6d4:	0f 93       	push	r16
     6d6:	1f 93       	push	r17
     6d8:	f8 01       	movw	r30, r16
     6da:	61 11       	cpse	r22, r1
     6dc:	03 c0       	rjmp	.+6      	; 0x6e4 <prvInitialiseNewQueue+0x10>
     6de:	11 83       	std	Z+1, r17	; 0x01
     6e0:	00 83       	st	Z, r16
     6e2:	02 c0       	rjmp	.+4      	; 0x6e8 <prvInitialiseNewQueue+0x14>
     6e4:	51 83       	std	Z+1, r21	; 0x01
     6e6:	40 83       	st	Z, r20
     6e8:	83 8f       	std	Z+27, r24	; 0x1b
     6ea:	64 8f       	std	Z+28, r22	; 0x1c
     6ec:	61 e0       	ldi	r22, 0x01	; 1
     6ee:	cf 01       	movw	r24, r30
     6f0:	0e 94 24 03 	call	0x648	; 0x648 <xQueueGenericReset>
     6f4:	1f 91       	pop	r17
     6f6:	0f 91       	pop	r16
     6f8:	08 95       	ret

000006fa <xQueueGenericCreate>:
     6fa:	df 92       	push	r13
     6fc:	ef 92       	push	r14
     6fe:	ff 92       	push	r15
     700:	0f 93       	push	r16
     702:	1f 93       	push	r17
     704:	cf 93       	push	r28
     706:	df 93       	push	r29
     708:	e8 2e       	mov	r14, r24
     70a:	f6 2e       	mov	r15, r22
     70c:	d4 2e       	mov	r13, r20
     70e:	66 23       	and	r22, r22
     710:	21 f0       	breq	.+8      	; 0x71a <xQueueGenericCreate+0x20>
     712:	86 9f       	mul	r24, r22
     714:	c0 01       	movw	r24, r0
     716:	11 24       	eor	r1, r1
     718:	02 c0       	rjmp	.+4      	; 0x71e <xQueueGenericCreate+0x24>
     71a:	80 e0       	ldi	r24, 0x00	; 0
     71c:	90 e0       	ldi	r25, 0x00	; 0
     71e:	4f 96       	adiw	r24, 0x1f	; 31
     720:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
     724:	ec 01       	movw	r28, r24
     726:	00 97       	sbiw	r24, 0x00	; 0
     728:	49 f0       	breq	.+18     	; 0x73c <xQueueGenericCreate+0x42>
     72a:	8c 01       	movw	r16, r24
     72c:	2d 2d       	mov	r18, r13
     72e:	ac 01       	movw	r20, r24
     730:	41 5e       	subi	r20, 0xE1	; 225
     732:	5f 4f       	sbci	r21, 0xFF	; 255
     734:	6f 2d       	mov	r22, r15
     736:	8e 2d       	mov	r24, r14
     738:	0e 94 6a 03 	call	0x6d4	; 0x6d4 <prvInitialiseNewQueue>
     73c:	ce 01       	movw	r24, r28
     73e:	df 91       	pop	r29
     740:	cf 91       	pop	r28
     742:	1f 91       	pop	r17
     744:	0f 91       	pop	r16
     746:	ff 90       	pop	r15
     748:	ef 90       	pop	r14
     74a:	df 90       	pop	r13
     74c:	08 95       	ret

0000074e <xQueueGenericSend>:
     74e:	cf 92       	push	r12
     750:	df 92       	push	r13
     752:	ef 92       	push	r14
     754:	ff 92       	push	r15
     756:	0f 93       	push	r16
     758:	1f 93       	push	r17
     75a:	cf 93       	push	r28
     75c:	df 93       	push	r29
     75e:	00 d0       	rcall	.+0      	; 0x760 <xQueueGenericSend+0x12>
     760:	00 d0       	rcall	.+0      	; 0x762 <xQueueGenericSend+0x14>
     762:	1f 92       	push	r1
     764:	cd b7       	in	r28, 0x3d	; 61
     766:	de b7       	in	r29, 0x3e	; 62
     768:	8c 01       	movw	r16, r24
     76a:	7b 01       	movw	r14, r22
     76c:	5d 83       	std	Y+5, r21	; 0x05
     76e:	4c 83       	std	Y+4, r20	; 0x04
     770:	c2 2e       	mov	r12, r18
     772:	d1 2c       	mov	r13, r1
     774:	0f b6       	in	r0, 0x3f	; 63
     776:	f8 94       	cli
     778:	0f 92       	push	r0
     77a:	f8 01       	movw	r30, r16
     77c:	92 8d       	ldd	r25, Z+26	; 0x1a
     77e:	83 8d       	ldd	r24, Z+27	; 0x1b
     780:	98 17       	cp	r25, r24
     782:	18 f0       	brcs	.+6      	; 0x78a <xQueueGenericSend+0x3c>
     784:	f2 e0       	ldi	r31, 0x02	; 2
     786:	cf 12       	cpse	r12, r31
     788:	19 c0       	rjmp	.+50     	; 0x7bc <xQueueGenericSend+0x6e>
     78a:	4c 2d       	mov	r20, r12
     78c:	b7 01       	movw	r22, r14
     78e:	c8 01       	movw	r24, r16
     790:	0e 94 91 02 	call	0x522	; 0x522 <prvCopyDataToQueue>
     794:	f8 01       	movw	r30, r16
     796:	91 89       	ldd	r25, Z+17	; 0x11
     798:	99 23       	and	r25, r25
     79a:	49 f0       	breq	.+18     	; 0x7ae <xQueueGenericSend+0x60>
     79c:	c8 01       	movw	r24, r16
     79e:	41 96       	adiw	r24, 0x11	; 17
     7a0:	0e 94 c9 08 	call	0x1192	; 0x1192 <xTaskRemoveFromEventList>
     7a4:	88 23       	and	r24, r24
     7a6:	31 f0       	breq	.+12     	; 0x7b4 <xQueueGenericSend+0x66>
     7a8:	0e 94 ae 01 	call	0x35c	; 0x35c <vPortYield>
     7ac:	03 c0       	rjmp	.+6      	; 0x7b4 <xQueueGenericSend+0x66>
     7ae:	81 11       	cpse	r24, r1
     7b0:	0e 94 ae 01 	call	0x35c	; 0x35c <vPortYield>
     7b4:	0f 90       	pop	r0
     7b6:	0f be       	out	0x3f, r0	; 63
     7b8:	81 e0       	ldi	r24, 0x01	; 1
     7ba:	4d c0       	rjmp	.+154    	; 0x856 <__DATA_REGION_LENGTH__+0x56>
     7bc:	8c 81       	ldd	r24, Y+4	; 0x04
     7be:	9d 81       	ldd	r25, Y+5	; 0x05
     7c0:	89 2b       	or	r24, r25
     7c2:	21 f4       	brne	.+8      	; 0x7cc <xQueueGenericSend+0x7e>
     7c4:	0f 90       	pop	r0
     7c6:	0f be       	out	0x3f, r0	; 63
     7c8:	80 e0       	ldi	r24, 0x00	; 0
     7ca:	45 c0       	rjmp	.+138    	; 0x856 <__DATA_REGION_LENGTH__+0x56>
     7cc:	d1 10       	cpse	r13, r1
     7ce:	06 c0       	rjmp	.+12     	; 0x7dc <xQueueGenericSend+0x8e>
     7d0:	ce 01       	movw	r24, r28
     7d2:	01 96       	adiw	r24, 0x01	; 1
     7d4:	0e 94 11 09 	call	0x1222	; 0x1222 <vTaskInternalSetTimeOutState>
     7d8:	dd 24       	eor	r13, r13
     7da:	d3 94       	inc	r13
     7dc:	0f 90       	pop	r0
     7de:	0f be       	out	0x3f, r0	; 63
     7e0:	0e 94 1b 07 	call	0xe36	; 0xe36 <vTaskSuspendAll>
     7e4:	0f b6       	in	r0, 0x3f	; 63
     7e6:	f8 94       	cli
     7e8:	0f 92       	push	r0
     7ea:	f8 01       	movw	r30, r16
     7ec:	85 8d       	ldd	r24, Z+29	; 0x1d
     7ee:	8f 3f       	cpi	r24, 0xFF	; 255
     7f0:	09 f4       	brne	.+2      	; 0x7f4 <xQueueGenericSend+0xa6>
     7f2:	15 8e       	std	Z+29, r1	; 0x1d
     7f4:	f8 01       	movw	r30, r16
     7f6:	86 8d       	ldd	r24, Z+30	; 0x1e
     7f8:	8f 3f       	cpi	r24, 0xFF	; 255
     7fa:	09 f4       	brne	.+2      	; 0x7fe <xQueueGenericSend+0xb0>
     7fc:	16 8e       	std	Z+30, r1	; 0x1e
     7fe:	0f 90       	pop	r0
     800:	0f be       	out	0x3f, r0	; 63
     802:	be 01       	movw	r22, r28
     804:	6c 5f       	subi	r22, 0xFC	; 252
     806:	7f 4f       	sbci	r23, 0xFF	; 255
     808:	ce 01       	movw	r24, r28
     80a:	01 96       	adiw	r24, 0x01	; 1
     80c:	0e 94 1c 09 	call	0x1238	; 0x1238 <xTaskCheckForTimeOut>
     810:	81 11       	cpse	r24, r1
     812:	1b c0       	rjmp	.+54     	; 0x84a <__DATA_REGION_LENGTH__+0x4a>
     814:	c8 01       	movw	r24, r16
     816:	0e 94 83 02 	call	0x506	; 0x506 <prvIsQueueFull>
     81a:	88 23       	and	r24, r24
     81c:	81 f0       	breq	.+32     	; 0x83e <__DATA_REGION_LENGTH__+0x3e>
     81e:	6c 81       	ldd	r22, Y+4	; 0x04
     820:	7d 81       	ldd	r23, Y+5	; 0x05
     822:	c8 01       	movw	r24, r16
     824:	08 96       	adiw	r24, 0x08	; 8
     826:	0e 94 b7 08 	call	0x116e	; 0x116e <vTaskPlaceOnEventList>
     82a:	c8 01       	movw	r24, r16
     82c:	0e 94 f0 02 	call	0x5e0	; 0x5e0 <prvUnlockQueue>
     830:	0e 94 db 07 	call	0xfb6	; 0xfb6 <xTaskResumeAll>
     834:	81 11       	cpse	r24, r1
     836:	9e cf       	rjmp	.-196    	; 0x774 <xQueueGenericSend+0x26>
     838:	0e 94 ae 01 	call	0x35c	; 0x35c <vPortYield>
     83c:	9b cf       	rjmp	.-202    	; 0x774 <xQueueGenericSend+0x26>
     83e:	c8 01       	movw	r24, r16
     840:	0e 94 f0 02 	call	0x5e0	; 0x5e0 <prvUnlockQueue>
     844:	0e 94 db 07 	call	0xfb6	; 0xfb6 <xTaskResumeAll>
     848:	95 cf       	rjmp	.-214    	; 0x774 <xQueueGenericSend+0x26>
     84a:	c8 01       	movw	r24, r16
     84c:	0e 94 f0 02 	call	0x5e0	; 0x5e0 <prvUnlockQueue>
     850:	0e 94 db 07 	call	0xfb6	; 0xfb6 <xTaskResumeAll>
     854:	80 e0       	ldi	r24, 0x00	; 0
     856:	0f 90       	pop	r0
     858:	0f 90       	pop	r0
     85a:	0f 90       	pop	r0
     85c:	0f 90       	pop	r0
     85e:	0f 90       	pop	r0
     860:	df 91       	pop	r29
     862:	cf 91       	pop	r28
     864:	1f 91       	pop	r17
     866:	0f 91       	pop	r16
     868:	ff 90       	pop	r15
     86a:	ef 90       	pop	r14
     86c:	df 90       	pop	r13
     86e:	cf 90       	pop	r12
     870:	08 95       	ret

00000872 <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
     872:	ef 92       	push	r14
     874:	ff 92       	push	r15
     876:	0f 93       	push	r16
     878:	1f 93       	push	r17
     87a:	cf 93       	push	r28
     87c:	df 93       	push	r29
     87e:	00 d0       	rcall	.+0      	; 0x880 <xQueueSemaphoreTake+0xe>
     880:	00 d0       	rcall	.+0      	; 0x882 <xQueueSemaphoreTake+0x10>
     882:	1f 92       	push	r1
     884:	cd b7       	in	r28, 0x3d	; 61
     886:	de b7       	in	r29, 0x3e	; 62
     888:	8c 01       	movw	r16, r24
     88a:	7d 83       	std	Y+5, r23	; 0x05
     88c:	6c 83       	std	Y+4, r22	; 0x04
BaseType_t xEntryTimeSet = pdFALSE;
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;

#if( configUSE_MUTEXES == 1 )
	BaseType_t xInheritanceOccurred = pdFALSE;
     88e:	e1 2c       	mov	r14, r1
}
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
BaseType_t xEntryTimeSet = pdFALSE;
     890:	f1 2c       	mov	r15, r1
	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
     892:	0f b6       	in	r0, 0x3f	; 63
     894:	f8 94       	cli
     896:	0f 92       	push	r0
		{
			/* Semaphores are queues with an item size of 0, and where the
			number of messages in the queue is the semaphore's count value. */
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
     898:	f8 01       	movw	r30, r16
     89a:	82 8d       	ldd	r24, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
     89c:	88 23       	and	r24, r24
     89e:	d1 f0       	breq	.+52     	; 0x8d4 <xQueueSemaphoreTake+0x62>
			{
				traceQUEUE_RECEIVE( pxQueue );

				/* Semaphores are queues with a data size of zero and where the
				messages waiting is the semaphore's count.  Reduce the count. */
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
     8a0:	81 50       	subi	r24, 0x01	; 1
     8a2:	82 8f       	std	Z+26, r24	; 0x1a

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
     8a4:	80 81       	ld	r24, Z
     8a6:	91 81       	ldd	r25, Z+1	; 0x01
     8a8:	89 2b       	or	r24, r25
     8aa:	29 f4       	brne	.+10     	; 0x8b6 <xQueueSemaphoreTake+0x44>
					{
						/* Record the information required to implement
						priority inheritance should it become necessary. */
						pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
     8ac:	0e 94 5e 0a 	call	0x14bc	; 0x14bc <pvTaskIncrementMutexHeldCount>
     8b0:	f8 01       	movw	r30, r16
     8b2:	95 83       	std	Z+5, r25	; 0x05
     8b4:	84 83       	std	Z+4, r24	; 0x04
				}
				#endif /* configUSE_MUTEXES */

				/* Check to see if other tasks are blocked waiting to give the
				semaphore, and if so, unblock the highest priority such task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     8b6:	f8 01       	movw	r30, r16
     8b8:	80 85       	ldd	r24, Z+8	; 0x08
     8ba:	88 23       	and	r24, r24
     8bc:	39 f0       	breq	.+14     	; 0x8cc <xQueueSemaphoreTake+0x5a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     8be:	c8 01       	movw	r24, r16
     8c0:	08 96       	adiw	r24, 0x08	; 8
     8c2:	0e 94 c9 08 	call	0x1192	; 0x1192 <xTaskRemoveFromEventList>
     8c6:	81 11       	cpse	r24, r1
					{
						queueYIELD_IF_USING_PREEMPTION();
     8c8:	0e 94 ae 01 	call	0x35c	; 0x35c <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
     8cc:	0f 90       	pop	r0
     8ce:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
     8d0:	81 e0       	ldi	r24, 0x01	; 1
     8d2:	74 c0       	rjmp	.+232    	; 0x9bc <xQueueSemaphoreTake+0x14a>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
     8d4:	8c 81       	ldd	r24, Y+4	; 0x04
     8d6:	9d 81       	ldd	r25, Y+5	; 0x05
     8d8:	89 2b       	or	r24, r25
     8da:	21 f4       	brne	.+8      	; 0x8e4 <xQueueSemaphoreTake+0x72>
					}
					#endif /* configUSE_MUTEXES */

					/* The semaphore count was 0 and no block time is specified
					(or the block time has expired) so exit now. */
					taskEXIT_CRITICAL();
     8dc:	0f 90       	pop	r0
     8de:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
     8e0:	80 e0       	ldi	r24, 0x00	; 0
     8e2:	6c c0       	rjmp	.+216    	; 0x9bc <xQueueSemaphoreTake+0x14a>
				}
				else if( xEntryTimeSet == pdFALSE )
     8e4:	f1 10       	cpse	r15, r1
     8e6:	06 c0       	rjmp	.+12     	; 0x8f4 <xQueueSemaphoreTake+0x82>
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
     8e8:	ce 01       	movw	r24, r28
     8ea:	01 96       	adiw	r24, 0x01	; 1
     8ec:	0e 94 11 09 	call	0x1222	; 0x1222 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
     8f0:	ff 24       	eor	r15, r15
     8f2:	f3 94       	inc	r15
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
     8f4:	0f 90       	pop	r0
     8f6:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
     8f8:	0e 94 1b 07 	call	0xe36	; 0xe36 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     8fc:	0f b6       	in	r0, 0x3f	; 63
     8fe:	f8 94       	cli
     900:	0f 92       	push	r0
     902:	f8 01       	movw	r30, r16
     904:	85 8d       	ldd	r24, Z+29	; 0x1d
     906:	8f 3f       	cpi	r24, 0xFF	; 255
     908:	09 f4       	brne	.+2      	; 0x90c <xQueueSemaphoreTake+0x9a>
     90a:	15 8e       	std	Z+29, r1	; 0x1d
     90c:	f8 01       	movw	r30, r16
     90e:	86 8d       	ldd	r24, Z+30	; 0x1e
     910:	8f 3f       	cpi	r24, 0xFF	; 255
     912:	09 f4       	brne	.+2      	; 0x916 <xQueueSemaphoreTake+0xa4>
     914:	16 8e       	std	Z+30, r1	; 0x1e
     916:	0f 90       	pop	r0
     918:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     91a:	be 01       	movw	r22, r28
     91c:	6c 5f       	subi	r22, 0xFC	; 252
     91e:	7f 4f       	sbci	r23, 0xFF	; 255
     920:	ce 01       	movw	r24, r28
     922:	01 96       	adiw	r24, 0x01	; 1
     924:	0e 94 1c 09 	call	0x1238	; 0x1238 <xTaskCheckForTimeOut>
     928:	81 11       	cpse	r24, r1
     92a:	2a c0       	rjmp	.+84     	; 0x980 <xQueueSemaphoreTake+0x10e>
		{
			/* A block time is specified and not expired.  If the semaphore
			count is 0 then enter the Blocked state to wait for a semaphore to
			become available.  As semaphores are implemented with queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     92c:	c8 01       	movw	r24, r16
     92e:	0e 94 76 02 	call	0x4ec	; 0x4ec <prvIsQueueEmpty>
     932:	88 23       	and	r24, r24
     934:	f9 f0       	breq	.+62     	; 0x974 <xQueueSemaphoreTake+0x102>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
     936:	f8 01       	movw	r30, r16
     938:	80 81       	ld	r24, Z
     93a:	91 81       	ldd	r25, Z+1	; 0x01
     93c:	89 2b       	or	r24, r25
     93e:	51 f4       	brne	.+20     	; 0x954 <xQueueSemaphoreTake+0xe2>
					{
						taskENTER_CRITICAL();
     940:	0f b6       	in	r0, 0x3f	; 63
     942:	f8 94       	cli
     944:	0f 92       	push	r0
						{
							xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
     946:	84 81       	ldd	r24, Z+4	; 0x04
     948:	95 81       	ldd	r25, Z+5	; 0x05
     94a:	0e 94 5c 09 	call	0x12b8	; 0x12b8 <xTaskPriorityInherit>
     94e:	e8 2e       	mov	r14, r24
						}
						taskEXIT_CRITICAL();
     950:	0f 90       	pop	r0
     952:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     954:	6c 81       	ldd	r22, Y+4	; 0x04
     956:	7d 81       	ldd	r23, Y+5	; 0x05
     958:	c8 01       	movw	r24, r16
     95a:	41 96       	adiw	r24, 0x11	; 17
     95c:	0e 94 b7 08 	call	0x116e	; 0x116e <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
     960:	c8 01       	movw	r24, r16
     962:	0e 94 f0 02 	call	0x5e0	; 0x5e0 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
     966:	0e 94 db 07 	call	0xfb6	; 0xfb6 <xTaskResumeAll>
     96a:	81 11       	cpse	r24, r1
     96c:	92 cf       	rjmp	.-220    	; 0x892 <xQueueSemaphoreTake+0x20>
				{
					portYIELD_WITHIN_API();
     96e:	0e 94 ae 01 	call	0x35c	; 0x35c <vPortYield>
     972:	8f cf       	rjmp	.-226    	; 0x892 <xQueueSemaphoreTake+0x20>
			}
			else
			{
				/* There was no timeout and the semaphore count was not 0, so
				attempt to take the semaphore again. */
				prvUnlockQueue( pxQueue );
     974:	c8 01       	movw	r24, r16
     976:	0e 94 f0 02 	call	0x5e0	; 0x5e0 <prvUnlockQueue>
				( void ) xTaskResumeAll();
     97a:	0e 94 db 07 	call	0xfb6	; 0xfb6 <xTaskResumeAll>
     97e:	89 cf       	rjmp	.-238    	; 0x892 <xQueueSemaphoreTake+0x20>
			}
		}
		else
		{
			/* Timed out. */
			prvUnlockQueue( pxQueue );
     980:	c8 01       	movw	r24, r16
     982:	0e 94 f0 02 	call	0x5e0	; 0x5e0 <prvUnlockQueue>
			( void ) xTaskResumeAll();
     986:	0e 94 db 07 	call	0xfb6	; 0xfb6 <xTaskResumeAll>

			/* If the semaphore count is 0 exit now as the timeout has
			expired.  Otherwise return to attempt to take the semaphore that is
			known to be available.  As semaphores are implemented by queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     98a:	c8 01       	movw	r24, r16
     98c:	0e 94 76 02 	call	0x4ec	; 0x4ec <prvIsQueueEmpty>
     990:	88 23       	and	r24, r24
     992:	09 f4       	brne	.+2      	; 0x996 <xQueueSemaphoreTake+0x124>
     994:	7e cf       	rjmp	.-260    	; 0x892 <xQueueSemaphoreTake+0x20>
				#if ( configUSE_MUTEXES == 1 )
				{
					/* xInheritanceOccurred could only have be set if
					pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to
					test the mutex type again to check it is actually a mutex. */
					if( xInheritanceOccurred != pdFALSE )
     996:	ee 20       	and	r14, r14
     998:	81 f0       	breq	.+32     	; 0x9ba <xQueueSemaphoreTake+0x148>
					{
						taskENTER_CRITICAL();
     99a:	0f b6       	in	r0, 0x3f	; 63
     99c:	f8 94       	cli
     99e:	0f 92       	push	r0
							/* This task blocking on the mutex caused another
							task to inherit this task's priority.  Now this task
							has timed out the priority should be disinherited
							again, but only as low as the next highest priority
							task that is waiting for the same mutex. */
							uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
     9a0:	c8 01       	movw	r24, r16
     9a2:	0e 94 66 02 	call	0x4cc	; 0x4cc <prvGetDisinheritPriorityAfterTimeout>
							vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
     9a6:	68 2f       	mov	r22, r24
     9a8:	f8 01       	movw	r30, r16
     9aa:	84 81       	ldd	r24, Z+4	; 0x04
     9ac:	95 81       	ldd	r25, Z+5	; 0x05
     9ae:	0e 94 0e 0a 	call	0x141c	; 0x141c <vTaskPriorityDisinheritAfterTimeout>
						}
						taskEXIT_CRITICAL();
     9b2:	0f 90       	pop	r0
     9b4:	0f be       	out	0x3f, r0	; 63
					}
				}
				#endif /* configUSE_MUTEXES */

				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
     9b6:	80 e0       	ldi	r24, 0x00	; 0
     9b8:	01 c0       	rjmp	.+2      	; 0x9bc <xQueueSemaphoreTake+0x14a>
     9ba:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
     9bc:	0f 90       	pop	r0
     9be:	0f 90       	pop	r0
     9c0:	0f 90       	pop	r0
     9c2:	0f 90       	pop	r0
     9c4:	0f 90       	pop	r0
     9c6:	df 91       	pop	r29
     9c8:	cf 91       	pop	r28
     9ca:	1f 91       	pop	r17
     9cc:	0f 91       	pop	r16
     9ce:	ff 90       	pop	r15
     9d0:	ef 90       	pop	r14
     9d2:	08 95       	ret

000009d4 <prvResetNextTaskUnblockTime>:
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
     9d4:	e0 91 f0 06 	lds	r30, 0x06F0	; 0x8006f0 <pxDelayedTaskList>
     9d8:	f0 91 f1 06 	lds	r31, 0x06F1	; 0x8006f1 <pxDelayedTaskList+0x1>
     9dc:	80 81       	ld	r24, Z
     9de:	81 11       	cpse	r24, r1
     9e0:	07 c0       	rjmp	.+14     	; 0x9f0 <prvResetNextTaskUnblockTime+0x1c>
     9e2:	8f ef       	ldi	r24, 0xFF	; 255
     9e4:	9f ef       	ldi	r25, 0xFF	; 255
     9e6:	90 93 c8 06 	sts	0x06C8, r25	; 0x8006c8 <xNextTaskUnblockTime+0x1>
     9ea:	80 93 c7 06 	sts	0x06C7, r24	; 0x8006c7 <xNextTaskUnblockTime>
     9ee:	08 95       	ret
     9f0:	e0 91 f0 06 	lds	r30, 0x06F0	; 0x8006f0 <pxDelayedTaskList>
     9f4:	f0 91 f1 06 	lds	r31, 0x06F1	; 0x8006f1 <pxDelayedTaskList+0x1>
     9f8:	05 80       	ldd	r0, Z+5	; 0x05
     9fa:	f6 81       	ldd	r31, Z+6	; 0x06
     9fc:	e0 2d       	mov	r30, r0
     9fe:	06 80       	ldd	r0, Z+6	; 0x06
     a00:	f7 81       	ldd	r31, Z+7	; 0x07
     a02:	e0 2d       	mov	r30, r0
     a04:	82 81       	ldd	r24, Z+2	; 0x02
     a06:	93 81       	ldd	r25, Z+3	; 0x03
     a08:	90 93 c8 06 	sts	0x06C8, r25	; 0x8006c8 <xNextTaskUnblockTime+0x1>
     a0c:	80 93 c7 06 	sts	0x06C7, r24	; 0x8006c7 <xNextTaskUnblockTime>
     a10:	08 95       	ret

00000a12 <prvDeleteTCB>:
     a12:	cf 93       	push	r28
     a14:	df 93       	push	r29
     a16:	ec 01       	movw	r28, r24
     a18:	8f 89       	ldd	r24, Y+23	; 0x17
     a1a:	98 8d       	ldd	r25, Y+24	; 0x18
     a1c:	0e 94 7e 00 	call	0xfc	; 0xfc <vPortFree>
     a20:	ce 01       	movw	r24, r28
     a22:	0e 94 7e 00 	call	0xfc	; 0xfc <vPortFree>
     a26:	df 91       	pop	r29
     a28:	cf 91       	pop	r28
     a2a:	08 95       	ret

00000a2c <prvInitialiseNewTask>:
     a2c:	6f 92       	push	r6
     a2e:	7f 92       	push	r7
     a30:	8f 92       	push	r8
     a32:	9f 92       	push	r9
     a34:	af 92       	push	r10
     a36:	bf 92       	push	r11
     a38:	cf 92       	push	r12
     a3a:	df 92       	push	r13
     a3c:	ef 92       	push	r14
     a3e:	0f 93       	push	r16
     a40:	1f 93       	push	r17
     a42:	cf 93       	push	r28
     a44:	df 93       	push	r29
     a46:	cd b7       	in	r28, 0x3d	; 61
     a48:	de b7       	in	r29, 0x3e	; 62
     a4a:	4c 01       	movw	r8, r24
     a4c:	f5 01       	movw	r30, r10
     a4e:	87 89       	ldd	r24, Z+23	; 0x17
     a50:	90 8d       	ldd	r25, Z+24	; 0x18
     a52:	21 50       	subi	r18, 0x01	; 1
     a54:	31 09       	sbc	r19, r1
     a56:	3c 01       	movw	r6, r24
     a58:	62 0e       	add	r6, r18
     a5a:	73 1e       	adc	r7, r19
     a5c:	61 15       	cp	r22, r1
     a5e:	71 05       	cpc	r23, r1
     a60:	89 f4       	brne	.+34     	; 0xa84 <prvInitialiseNewTask+0x58>
     a62:	16 c0       	rjmp	.+44     	; 0xa90 <prvInitialiseNewTask+0x64>
     a64:	82 2f       	mov	r24, r18
     a66:	90 e0       	ldi	r25, 0x00	; 0
     a68:	fb 01       	movw	r30, r22
     a6a:	e8 0f       	add	r30, r24
     a6c:	f9 1f       	adc	r31, r25
     a6e:	30 81       	ld	r19, Z
     a70:	d5 01       	movw	r26, r10
     a72:	a8 0f       	add	r26, r24
     a74:	b9 1f       	adc	r27, r25
     a76:	59 96       	adiw	r26, 0x19	; 25
     a78:	3c 93       	st	X, r19
     a7a:	80 81       	ld	r24, Z
     a7c:	88 23       	and	r24, r24
     a7e:	29 f0       	breq	.+10     	; 0xa8a <prvInitialiseNewTask+0x5e>
     a80:	2f 5f       	subi	r18, 0xFF	; 255
     a82:	01 c0       	rjmp	.+2      	; 0xa86 <prvInitialiseNewTask+0x5a>
     a84:	20 e0       	ldi	r18, 0x00	; 0
     a86:	28 30       	cpi	r18, 0x08	; 8
     a88:	68 f3       	brcs	.-38     	; 0xa64 <prvInitialiseNewTask+0x38>
     a8a:	f5 01       	movw	r30, r10
     a8c:	10 a2       	std	Z+32, r1	; 0x20
     a8e:	02 c0       	rjmp	.+4      	; 0xa94 <prvInitialiseNewTask+0x68>
     a90:	f5 01       	movw	r30, r10
     a92:	11 8e       	std	Z+25, r1	; 0x19
     a94:	f7 e0       	ldi	r31, 0x07	; 7
     a96:	fe 15       	cp	r31, r14
     a98:	20 f4       	brcc	.+8      	; 0xaa2 <prvInitialiseNewTask+0x76>
     a9a:	0f 2e       	mov	r0, r31
     a9c:	f7 e0       	ldi	r31, 0x07	; 7
     a9e:	ef 2e       	mov	r14, r31
     aa0:	f0 2d       	mov	r31, r0
     aa2:	f5 01       	movw	r30, r10
     aa4:	e6 8a       	std	Z+22, r14	; 0x16
     aa6:	e1 a2       	std	Z+33, r14	; 0x21
     aa8:	12 a2       	std	Z+34, r1	; 0x22
     aaa:	c5 01       	movw	r24, r10
     aac:	02 96       	adiw	r24, 0x02	; 2
     aae:	0e 94 8d 00 	call	0x11a	; 0x11a <vListInitialiseItem>
     ab2:	c5 01       	movw	r24, r10
     ab4:	0c 96       	adiw	r24, 0x0c	; 12
     ab6:	0e 94 8d 00 	call	0x11a	; 0x11a <vListInitialiseItem>
     aba:	f5 01       	movw	r30, r10
     abc:	b1 86       	std	Z+9, r11	; 0x09
     abe:	a0 86       	std	Z+8, r10	; 0x08
     ac0:	88 e0       	ldi	r24, 0x08	; 8
     ac2:	90 e0       	ldi	r25, 0x00	; 0
     ac4:	8e 19       	sub	r24, r14
     ac6:	91 09       	sbc	r25, r1
     ac8:	95 87       	std	Z+13, r25	; 0x0d
     aca:	84 87       	std	Z+12, r24	; 0x0c
     acc:	b3 8a       	std	Z+19, r11	; 0x13
     ace:	a2 8a       	std	Z+18, r10	; 0x12
     ad0:	13 a2       	std	Z+35, r1	; 0x23
     ad2:	14 a2       	std	Z+36, r1	; 0x24
     ad4:	15 a2       	std	Z+37, r1	; 0x25
     ad6:	16 a2       	std	Z+38, r1	; 0x26
     ad8:	17 a2       	std	Z+39, r1	; 0x27
     ada:	a8 01       	movw	r20, r16
     adc:	b4 01       	movw	r22, r8
     ade:	c3 01       	movw	r24, r6
     ae0:	0e 94 13 01 	call	0x226	; 0x226 <pxPortInitialiseStack>
     ae4:	f5 01       	movw	r30, r10
     ae6:	91 83       	std	Z+1, r25	; 0x01
     ae8:	80 83       	st	Z, r24
     aea:	c1 14       	cp	r12, r1
     aec:	d1 04       	cpc	r13, r1
     aee:	19 f0       	breq	.+6      	; 0xaf6 <prvInitialiseNewTask+0xca>
     af0:	f6 01       	movw	r30, r12
     af2:	b1 82       	std	Z+1, r11	; 0x01
     af4:	a0 82       	st	Z, r10
     af6:	df 91       	pop	r29
     af8:	cf 91       	pop	r28
     afa:	1f 91       	pop	r17
     afc:	0f 91       	pop	r16
     afe:	ef 90       	pop	r14
     b00:	df 90       	pop	r13
     b02:	cf 90       	pop	r12
     b04:	bf 90       	pop	r11
     b06:	af 90       	pop	r10
     b08:	9f 90       	pop	r9
     b0a:	8f 90       	pop	r8
     b0c:	7f 90       	pop	r7
     b0e:	6f 90       	pop	r6
     b10:	08 95       	ret

00000b12 <prvInitialiseTaskLists>:
     b12:	cf 93       	push	r28
     b14:	c0 e0       	ldi	r28, 0x00	; 0
     b16:	10 c0       	rjmp	.+32     	; 0xb38 <prvInitialiseTaskLists+0x26>
     b18:	8c 2f       	mov	r24, r28
     b1a:	90 e0       	ldi	r25, 0x00	; 0
     b1c:	9c 01       	movw	r18, r24
     b1e:	22 0f       	add	r18, r18
     b20:	33 1f       	adc	r19, r19
     b22:	22 0f       	add	r18, r18
     b24:	33 1f       	adc	r19, r19
     b26:	22 0f       	add	r18, r18
     b28:	33 1f       	adc	r19, r19
     b2a:	82 0f       	add	r24, r18
     b2c:	93 1f       	adc	r25, r19
     b2e:	8c 5f       	subi	r24, 0xFC	; 252
     b30:	98 4f       	sbci	r25, 0xF8	; 248
     b32:	0e 94 7f 00 	call	0xfe	; 0xfe <vListInitialise>
     b36:	cf 5f       	subi	r28, 0xFF	; 255
     b38:	c8 30       	cpi	r28, 0x08	; 8
     b3a:	70 f3       	brcs	.-36     	; 0xb18 <prvInitialiseTaskLists+0x6>
     b3c:	8b ef       	ldi	r24, 0xFB	; 251
     b3e:	96 e0       	ldi	r25, 0x06	; 6
     b40:	0e 94 7f 00 	call	0xfe	; 0xfe <vListInitialise>
     b44:	82 ef       	ldi	r24, 0xF2	; 242
     b46:	96 e0       	ldi	r25, 0x06	; 6
     b48:	0e 94 7f 00 	call	0xfe	; 0xfe <vListInitialise>
     b4c:	85 ee       	ldi	r24, 0xE5	; 229
     b4e:	96 e0       	ldi	r25, 0x06	; 6
     b50:	0e 94 7f 00 	call	0xfe	; 0xfe <vListInitialise>
     b54:	8c ed       	ldi	r24, 0xDC	; 220
     b56:	96 e0       	ldi	r25, 0x06	; 6
     b58:	0e 94 7f 00 	call	0xfe	; 0xfe <vListInitialise>
     b5c:	82 ed       	ldi	r24, 0xD2	; 210
     b5e:	96 e0       	ldi	r25, 0x06	; 6
     b60:	0e 94 7f 00 	call	0xfe	; 0xfe <vListInitialise>
     b64:	8b ef       	ldi	r24, 0xFB	; 251
     b66:	96 e0       	ldi	r25, 0x06	; 6
     b68:	90 93 f1 06 	sts	0x06F1, r25	; 0x8006f1 <pxDelayedTaskList+0x1>
     b6c:	80 93 f0 06 	sts	0x06F0, r24	; 0x8006f0 <pxDelayedTaskList>
     b70:	82 ef       	ldi	r24, 0xF2	; 242
     b72:	96 e0       	ldi	r25, 0x06	; 6
     b74:	90 93 ef 06 	sts	0x06EF, r25	; 0x8006ef <pxOverflowDelayedTaskList+0x1>
     b78:	80 93 ee 06 	sts	0x06EE, r24	; 0x8006ee <pxOverflowDelayedTaskList>
     b7c:	cf 91       	pop	r28
     b7e:	08 95       	ret

00000b80 <prvAddNewTaskToReadyList>:
     b80:	cf 93       	push	r28
     b82:	df 93       	push	r29
     b84:	ec 01       	movw	r28, r24
     b86:	0f b6       	in	r0, 0x3f	; 63
     b88:	f8 94       	cli
     b8a:	0f 92       	push	r0
     b8c:	80 91 d1 06 	lds	r24, 0x06D1	; 0x8006d1 <uxCurrentNumberOfTasks>
     b90:	8f 5f       	subi	r24, 0xFF	; 255
     b92:	80 93 d1 06 	sts	0x06D1, r24	; 0x8006d1 <uxCurrentNumberOfTasks>
     b96:	80 91 4c 07 	lds	r24, 0x074C	; 0x80074c <pxCurrentTCB>
     b9a:	90 91 4d 07 	lds	r25, 0x074D	; 0x80074d <pxCurrentTCB+0x1>
     b9e:	89 2b       	or	r24, r25
     ba0:	59 f4       	brne	.+22     	; 0xbb8 <prvAddNewTaskToReadyList+0x38>
     ba2:	d0 93 4d 07 	sts	0x074D, r29	; 0x80074d <pxCurrentTCB+0x1>
     ba6:	c0 93 4c 07 	sts	0x074C, r28	; 0x80074c <pxCurrentTCB>
     baa:	80 91 d1 06 	lds	r24, 0x06D1	; 0x8006d1 <uxCurrentNumberOfTasks>
     bae:	81 30       	cpi	r24, 0x01	; 1
     bb0:	99 f4       	brne	.+38     	; 0xbd8 <prvAddNewTaskToReadyList+0x58>
     bb2:	0e 94 89 05 	call	0xb12	; 0xb12 <prvInitialiseTaskLists>
     bb6:	10 c0       	rjmp	.+32     	; 0xbd8 <prvAddNewTaskToReadyList+0x58>
     bb8:	80 91 cd 06 	lds	r24, 0x06CD	; 0x8006cd <xSchedulerRunning>
     bbc:	81 11       	cpse	r24, r1
     bbe:	0c c0       	rjmp	.+24     	; 0xbd8 <prvAddNewTaskToReadyList+0x58>
     bc0:	e0 91 4c 07 	lds	r30, 0x074C	; 0x80074c <pxCurrentTCB>
     bc4:	f0 91 4d 07 	lds	r31, 0x074D	; 0x80074d <pxCurrentTCB+0x1>
     bc8:	96 89       	ldd	r25, Z+22	; 0x16
     bca:	8e 89       	ldd	r24, Y+22	; 0x16
     bcc:	89 17       	cp	r24, r25
     bce:	20 f0       	brcs	.+8      	; 0xbd8 <prvAddNewTaskToReadyList+0x58>
     bd0:	d0 93 4d 07 	sts	0x074D, r29	; 0x80074d <pxCurrentTCB+0x1>
     bd4:	c0 93 4c 07 	sts	0x074C, r28	; 0x80074c <pxCurrentTCB>
     bd8:	80 91 c9 06 	lds	r24, 0x06C9	; 0x8006c9 <uxTaskNumber>
     bdc:	8f 5f       	subi	r24, 0xFF	; 255
     bde:	80 93 c9 06 	sts	0x06C9, r24	; 0x8006c9 <uxTaskNumber>
     be2:	8e 89       	ldd	r24, Y+22	; 0x16
     be4:	90 91 ce 06 	lds	r25, 0x06CE	; 0x8006ce <uxTopReadyPriority>
     be8:	98 17       	cp	r25, r24
     bea:	10 f4       	brcc	.+4      	; 0xbf0 <prvAddNewTaskToReadyList+0x70>
     bec:	80 93 ce 06 	sts	0x06CE, r24	; 0x8006ce <uxTopReadyPriority>
     bf0:	90 e0       	ldi	r25, 0x00	; 0
     bf2:	9c 01       	movw	r18, r24
     bf4:	22 0f       	add	r18, r18
     bf6:	33 1f       	adc	r19, r19
     bf8:	22 0f       	add	r18, r18
     bfa:	33 1f       	adc	r19, r19
     bfc:	22 0f       	add	r18, r18
     bfe:	33 1f       	adc	r19, r19
     c00:	82 0f       	add	r24, r18
     c02:	93 1f       	adc	r25, r19
     c04:	be 01       	movw	r22, r28
     c06:	6e 5f       	subi	r22, 0xFE	; 254
     c08:	7f 4f       	sbci	r23, 0xFF	; 255
     c0a:	8c 5f       	subi	r24, 0xFC	; 252
     c0c:	98 4f       	sbci	r25, 0xF8	; 248
     c0e:	0e 94 91 00 	call	0x122	; 0x122 <vListInsertEnd>
     c12:	0f 90       	pop	r0
     c14:	0f be       	out	0x3f, r0	; 63
     c16:	80 91 cd 06 	lds	r24, 0x06CD	; 0x8006cd <xSchedulerRunning>
     c1a:	88 23       	and	r24, r24
     c1c:	51 f0       	breq	.+20     	; 0xc32 <prvAddNewTaskToReadyList+0xb2>
     c1e:	e0 91 4c 07 	lds	r30, 0x074C	; 0x80074c <pxCurrentTCB>
     c22:	f0 91 4d 07 	lds	r31, 0x074D	; 0x80074d <pxCurrentTCB+0x1>
     c26:	96 89       	ldd	r25, Z+22	; 0x16
     c28:	8e 89       	ldd	r24, Y+22	; 0x16
     c2a:	98 17       	cp	r25, r24
     c2c:	10 f4       	brcc	.+4      	; 0xc32 <prvAddNewTaskToReadyList+0xb2>
     c2e:	0e 94 ae 01 	call	0x35c	; 0x35c <vPortYield>
     c32:	df 91       	pop	r29
     c34:	cf 91       	pop	r28
     c36:	08 95       	ret

00000c38 <prvCheckTasksWaitingTermination>:
     c38:	cf 93       	push	r28
     c3a:	df 93       	push	r29
     c3c:	1c c0       	rjmp	.+56     	; 0xc76 <prvCheckTasksWaitingTermination+0x3e>
     c3e:	0f b6       	in	r0, 0x3f	; 63
     c40:	f8 94       	cli
     c42:	0f 92       	push	r0
     c44:	e0 91 e1 06 	lds	r30, 0x06E1	; 0x8006e1 <xTasksWaitingTermination+0x5>
     c48:	f0 91 e2 06 	lds	r31, 0x06E2	; 0x8006e2 <xTasksWaitingTermination+0x6>
     c4c:	c6 81       	ldd	r28, Z+6	; 0x06
     c4e:	d7 81       	ldd	r29, Z+7	; 0x07
     c50:	ce 01       	movw	r24, r28
     c52:	02 96       	adiw	r24, 0x02	; 2
     c54:	0e 94 e3 00 	call	0x1c6	; 0x1c6 <uxListRemove>
     c58:	80 91 d1 06 	lds	r24, 0x06D1	; 0x8006d1 <uxCurrentNumberOfTasks>
     c5c:	81 50       	subi	r24, 0x01	; 1
     c5e:	80 93 d1 06 	sts	0x06D1, r24	; 0x8006d1 <uxCurrentNumberOfTasks>
     c62:	80 91 db 06 	lds	r24, 0x06DB	; 0x8006db <uxDeletedTasksWaitingCleanUp>
     c66:	81 50       	subi	r24, 0x01	; 1
     c68:	80 93 db 06 	sts	0x06DB, r24	; 0x8006db <uxDeletedTasksWaitingCleanUp>
     c6c:	0f 90       	pop	r0
     c6e:	0f be       	out	0x3f, r0	; 63
     c70:	ce 01       	movw	r24, r28
     c72:	0e 94 09 05 	call	0xa12	; 0xa12 <prvDeleteTCB>
     c76:	80 91 db 06 	lds	r24, 0x06DB	; 0x8006db <uxDeletedTasksWaitingCleanUp>
     c7a:	81 11       	cpse	r24, r1
     c7c:	e0 cf       	rjmp	.-64     	; 0xc3e <prvCheckTasksWaitingTermination+0x6>
     c7e:	df 91       	pop	r29
     c80:	cf 91       	pop	r28
     c82:	08 95       	ret

00000c84 <prvIdleTask>:
     c84:	0e 94 1c 06 	call	0xc38	; 0xc38 <prvCheckTasksWaitingTermination>
     c88:	fd cf       	rjmp	.-6      	; 0xc84 <prvIdleTask>

00000c8a <prvAddCurrentTaskToDelayedList>:
     c8a:	ff 92       	push	r15
     c8c:	0f 93       	push	r16
     c8e:	1f 93       	push	r17
     c90:	cf 93       	push	r28
     c92:	df 93       	push	r29
     c94:	ec 01       	movw	r28, r24
     c96:	f6 2e       	mov	r15, r22
     c98:	00 91 cf 06 	lds	r16, 0x06CF	; 0x8006cf <xTickCount>
     c9c:	10 91 d0 06 	lds	r17, 0x06D0	; 0x8006d0 <xTickCount+0x1>
     ca0:	80 91 4c 07 	lds	r24, 0x074C	; 0x80074c <pxCurrentTCB>
     ca4:	90 91 4d 07 	lds	r25, 0x074D	; 0x80074d <pxCurrentTCB+0x1>
     ca8:	02 96       	adiw	r24, 0x02	; 2
     caa:	0e 94 e3 00 	call	0x1c6	; 0x1c6 <uxListRemove>
     cae:	cf 3f       	cpi	r28, 0xFF	; 255
     cb0:	8f ef       	ldi	r24, 0xFF	; 255
     cb2:	d8 07       	cpc	r29, r24
     cb4:	69 f4       	brne	.+26     	; 0xcd0 <prvAddCurrentTaskToDelayedList+0x46>
     cb6:	ff 20       	and	r15, r15
     cb8:	59 f0       	breq	.+22     	; 0xcd0 <prvAddCurrentTaskToDelayedList+0x46>
     cba:	60 91 4c 07 	lds	r22, 0x074C	; 0x80074c <pxCurrentTCB>
     cbe:	70 91 4d 07 	lds	r23, 0x074D	; 0x80074d <pxCurrentTCB+0x1>
     cc2:	6e 5f       	subi	r22, 0xFE	; 254
     cc4:	7f 4f       	sbci	r23, 0xFF	; 255
     cc6:	82 ed       	ldi	r24, 0xD2	; 210
     cc8:	96 e0       	ldi	r25, 0x06	; 6
     cca:	0e 94 91 00 	call	0x122	; 0x122 <vListInsertEnd>
     cce:	2f c0       	rjmp	.+94     	; 0xd2e <prvAddCurrentTaskToDelayedList+0xa4>
     cd0:	c0 0f       	add	r28, r16
     cd2:	d1 1f       	adc	r29, r17
     cd4:	e0 91 4c 07 	lds	r30, 0x074C	; 0x80074c <pxCurrentTCB>
     cd8:	f0 91 4d 07 	lds	r31, 0x074D	; 0x80074d <pxCurrentTCB+0x1>
     cdc:	d3 83       	std	Z+3, r29	; 0x03
     cde:	c2 83       	std	Z+2, r28	; 0x02
     ce0:	c0 17       	cp	r28, r16
     ce2:	d1 07       	cpc	r29, r17
     ce4:	68 f4       	brcc	.+26     	; 0xd00 <prvAddCurrentTaskToDelayedList+0x76>
     ce6:	60 91 4c 07 	lds	r22, 0x074C	; 0x80074c <pxCurrentTCB>
     cea:	70 91 4d 07 	lds	r23, 0x074D	; 0x80074d <pxCurrentTCB+0x1>
     cee:	80 91 ee 06 	lds	r24, 0x06EE	; 0x8006ee <pxOverflowDelayedTaskList>
     cf2:	90 91 ef 06 	lds	r25, 0x06EF	; 0x8006ef <pxOverflowDelayedTaskList+0x1>
     cf6:	6e 5f       	subi	r22, 0xFE	; 254
     cf8:	7f 4f       	sbci	r23, 0xFF	; 255
     cfa:	0e 94 b2 00 	call	0x164	; 0x164 <vListInsert>
     cfe:	17 c0       	rjmp	.+46     	; 0xd2e <prvAddCurrentTaskToDelayedList+0xa4>
     d00:	60 91 4c 07 	lds	r22, 0x074C	; 0x80074c <pxCurrentTCB>
     d04:	70 91 4d 07 	lds	r23, 0x074D	; 0x80074d <pxCurrentTCB+0x1>
     d08:	80 91 f0 06 	lds	r24, 0x06F0	; 0x8006f0 <pxDelayedTaskList>
     d0c:	90 91 f1 06 	lds	r25, 0x06F1	; 0x8006f1 <pxDelayedTaskList+0x1>
     d10:	6e 5f       	subi	r22, 0xFE	; 254
     d12:	7f 4f       	sbci	r23, 0xFF	; 255
     d14:	0e 94 b2 00 	call	0x164	; 0x164 <vListInsert>
     d18:	80 91 c7 06 	lds	r24, 0x06C7	; 0x8006c7 <xNextTaskUnblockTime>
     d1c:	90 91 c8 06 	lds	r25, 0x06C8	; 0x8006c8 <xNextTaskUnblockTime+0x1>
     d20:	c8 17       	cp	r28, r24
     d22:	d9 07       	cpc	r29, r25
     d24:	20 f4       	brcc	.+8      	; 0xd2e <prvAddCurrentTaskToDelayedList+0xa4>
     d26:	d0 93 c8 06 	sts	0x06C8, r29	; 0x8006c8 <xNextTaskUnblockTime+0x1>
     d2a:	c0 93 c7 06 	sts	0x06C7, r28	; 0x8006c7 <xNextTaskUnblockTime>
     d2e:	df 91       	pop	r29
     d30:	cf 91       	pop	r28
     d32:	1f 91       	pop	r17
     d34:	0f 91       	pop	r16
     d36:	ff 90       	pop	r15
     d38:	08 95       	ret

00000d3a <xTaskCreate>:
     d3a:	2f 92       	push	r2
     d3c:	3f 92       	push	r3
     d3e:	4f 92       	push	r4
     d40:	5f 92       	push	r5
     d42:	6f 92       	push	r6
     d44:	7f 92       	push	r7
     d46:	8f 92       	push	r8
     d48:	9f 92       	push	r9
     d4a:	af 92       	push	r10
     d4c:	bf 92       	push	r11
     d4e:	cf 92       	push	r12
     d50:	df 92       	push	r13
     d52:	ef 92       	push	r14
     d54:	ff 92       	push	r15
     d56:	0f 93       	push	r16
     d58:	1f 93       	push	r17
     d5a:	cf 93       	push	r28
     d5c:	df 93       	push	r29
     d5e:	3c 01       	movw	r6, r24
     d60:	1b 01       	movw	r2, r22
     d62:	5a 01       	movw	r10, r20
     d64:	29 01       	movw	r4, r18
     d66:	ca 01       	movw	r24, r20
     d68:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
     d6c:	6c 01       	movw	r12, r24
     d6e:	89 2b       	or	r24, r25
     d70:	71 f0       	breq	.+28     	; 0xd8e <xTaskCreate+0x54>
     d72:	88 e2       	ldi	r24, 0x28	; 40
     d74:	90 e0       	ldi	r25, 0x00	; 0
     d76:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
     d7a:	ec 01       	movw	r28, r24
     d7c:	89 2b       	or	r24, r25
     d7e:	19 f0       	breq	.+6      	; 0xd86 <xTaskCreate+0x4c>
     d80:	d8 8e       	std	Y+24, r13	; 0x18
     d82:	cf 8a       	std	Y+23, r12	; 0x17
     d84:	06 c0       	rjmp	.+12     	; 0xd92 <xTaskCreate+0x58>
     d86:	c6 01       	movw	r24, r12
     d88:	0e 94 7e 00 	call	0xfc	; 0xfc <vPortFree>
     d8c:	02 c0       	rjmp	.+4      	; 0xd92 <xTaskCreate+0x58>
     d8e:	c0 e0       	ldi	r28, 0x00	; 0
     d90:	d0 e0       	ldi	r29, 0x00	; 0
     d92:	20 97       	sbiw	r28, 0x00	; 0
     d94:	91 f0       	breq	.+36     	; 0xdba <xTaskCreate+0x80>
     d96:	95 01       	movw	r18, r10
     d98:	40 e0       	ldi	r20, 0x00	; 0
     d9a:	50 e0       	ldi	r21, 0x00	; 0
     d9c:	81 2c       	mov	r8, r1
     d9e:	91 2c       	mov	r9, r1
     da0:	5e 01       	movw	r10, r28
     da2:	67 01       	movw	r12, r14
     da4:	e0 2e       	mov	r14, r16
     da6:	82 01       	movw	r16, r4
     da8:	b1 01       	movw	r22, r2
     daa:	c3 01       	movw	r24, r6
     dac:	0e 94 16 05 	call	0xa2c	; 0xa2c <prvInitialiseNewTask>
     db0:	ce 01       	movw	r24, r28
     db2:	0e 94 c0 05 	call	0xb80	; 0xb80 <prvAddNewTaskToReadyList>
     db6:	81 e0       	ldi	r24, 0x01	; 1
     db8:	01 c0       	rjmp	.+2      	; 0xdbc <xTaskCreate+0x82>
     dba:	8f ef       	ldi	r24, 0xFF	; 255
     dbc:	df 91       	pop	r29
     dbe:	cf 91       	pop	r28
     dc0:	1f 91       	pop	r17
     dc2:	0f 91       	pop	r16
     dc4:	ff 90       	pop	r15
     dc6:	ef 90       	pop	r14
     dc8:	df 90       	pop	r13
     dca:	cf 90       	pop	r12
     dcc:	bf 90       	pop	r11
     dce:	af 90       	pop	r10
     dd0:	9f 90       	pop	r9
     dd2:	8f 90       	pop	r8
     dd4:	7f 90       	pop	r7
     dd6:	6f 90       	pop	r6
     dd8:	5f 90       	pop	r5
     dda:	4f 90       	pop	r4
     ddc:	3f 90       	pop	r3
     dde:	2f 90       	pop	r2
     de0:	08 95       	ret

00000de2 <vTaskStartScheduler>:
     de2:	ef 92       	push	r14
     de4:	ff 92       	push	r15
     de6:	0f 93       	push	r16
     de8:	0f 2e       	mov	r0, r31
     dea:	f5 ec       	ldi	r31, 0xC5	; 197
     dec:	ef 2e       	mov	r14, r31
     dee:	f6 e0       	ldi	r31, 0x06	; 6
     df0:	ff 2e       	mov	r15, r31
     df2:	f0 2d       	mov	r31, r0
     df4:	00 e0       	ldi	r16, 0x00	; 0
     df6:	20 e0       	ldi	r18, 0x00	; 0
     df8:	30 e0       	ldi	r19, 0x00	; 0
     dfa:	45 e5       	ldi	r20, 0x55	; 85
     dfc:	50 e0       	ldi	r21, 0x00	; 0
     dfe:	68 e7       	ldi	r22, 0x78	; 120
     e00:	70 e0       	ldi	r23, 0x00	; 0
     e02:	82 e4       	ldi	r24, 0x42	; 66
     e04:	96 e0       	ldi	r25, 0x06	; 6
     e06:	0e 94 9d 06 	call	0xd3a	; 0xd3a <xTaskCreate>
     e0a:	81 30       	cpi	r24, 0x01	; 1
     e0c:	81 f4       	brne	.+32     	; 0xe2e <vTaskStartScheduler+0x4c>
     e0e:	f8 94       	cli
     e10:	8f ef       	ldi	r24, 0xFF	; 255
     e12:	9f ef       	ldi	r25, 0xFF	; 255
     e14:	90 93 c8 06 	sts	0x06C8, r25	; 0x8006c8 <xNextTaskUnblockTime+0x1>
     e18:	80 93 c7 06 	sts	0x06C7, r24	; 0x8006c7 <xNextTaskUnblockTime>
     e1c:	81 e0       	ldi	r24, 0x01	; 1
     e1e:	80 93 cd 06 	sts	0x06CD, r24	; 0x8006cd <xSchedulerRunning>
     e22:	10 92 d0 06 	sts	0x06D0, r1	; 0x8006d0 <xTickCount+0x1>
     e26:	10 92 cf 06 	sts	0x06CF, r1	; 0x8006cf <xTickCount>
     e2a:	0e 94 7f 01 	call	0x2fe	; 0x2fe <xPortStartScheduler>
     e2e:	0f 91       	pop	r16
     e30:	ff 90       	pop	r15
     e32:	ef 90       	pop	r14
     e34:	08 95       	ret

00000e36 <vTaskSuspendAll>:
     e36:	80 91 c4 06 	lds	r24, 0x06C4	; 0x8006c4 <uxSchedulerSuspended>
     e3a:	8f 5f       	subi	r24, 0xFF	; 255
     e3c:	80 93 c4 06 	sts	0x06C4, r24	; 0x8006c4 <uxSchedulerSuspended>
     e40:	08 95       	ret

00000e42 <xTaskIncrementTick>:
     e42:	df 92       	push	r13
     e44:	ef 92       	push	r14
     e46:	ff 92       	push	r15
     e48:	0f 93       	push	r16
     e4a:	1f 93       	push	r17
     e4c:	cf 93       	push	r28
     e4e:	df 93       	push	r29
     e50:	80 91 c4 06 	lds	r24, 0x06C4	; 0x8006c4 <uxSchedulerSuspended>
     e54:	81 11       	cpse	r24, r1
     e56:	97 c0       	rjmp	.+302    	; 0xf86 <xTaskIncrementTick+0x144>
     e58:	e0 90 cf 06 	lds	r14, 0x06CF	; 0x8006cf <xTickCount>
     e5c:	f0 90 d0 06 	lds	r15, 0x06D0	; 0x8006d0 <xTickCount+0x1>
     e60:	8f ef       	ldi	r24, 0xFF	; 255
     e62:	e8 1a       	sub	r14, r24
     e64:	f8 0a       	sbc	r15, r24
     e66:	f0 92 d0 06 	sts	0x06D0, r15	; 0x8006d0 <xTickCount+0x1>
     e6a:	e0 92 cf 06 	sts	0x06CF, r14	; 0x8006cf <xTickCount>
     e6e:	e1 14       	cp	r14, r1
     e70:	f1 04       	cpc	r15, r1
     e72:	b9 f4       	brne	.+46     	; 0xea2 <xTaskIncrementTick+0x60>
     e74:	80 91 f0 06 	lds	r24, 0x06F0	; 0x8006f0 <pxDelayedTaskList>
     e78:	90 91 f1 06 	lds	r25, 0x06F1	; 0x8006f1 <pxDelayedTaskList+0x1>
     e7c:	20 91 ee 06 	lds	r18, 0x06EE	; 0x8006ee <pxOverflowDelayedTaskList>
     e80:	30 91 ef 06 	lds	r19, 0x06EF	; 0x8006ef <pxOverflowDelayedTaskList+0x1>
     e84:	30 93 f1 06 	sts	0x06F1, r19	; 0x8006f1 <pxDelayedTaskList+0x1>
     e88:	20 93 f0 06 	sts	0x06F0, r18	; 0x8006f0 <pxDelayedTaskList>
     e8c:	90 93 ef 06 	sts	0x06EF, r25	; 0x8006ef <pxOverflowDelayedTaskList+0x1>
     e90:	80 93 ee 06 	sts	0x06EE, r24	; 0x8006ee <pxOverflowDelayedTaskList>
     e94:	80 91 ca 06 	lds	r24, 0x06CA	; 0x8006ca <xNumOfOverflows>
     e98:	8f 5f       	subi	r24, 0xFF	; 255
     e9a:	80 93 ca 06 	sts	0x06CA, r24	; 0x8006ca <xNumOfOverflows>
     e9e:	0e 94 ea 04 	call	0x9d4	; 0x9d4 <prvResetNextTaskUnblockTime>
     ea2:	80 91 c7 06 	lds	r24, 0x06C7	; 0x8006c7 <xNextTaskUnblockTime>
     ea6:	90 91 c8 06 	lds	r25, 0x06C8	; 0x8006c8 <xNextTaskUnblockTime+0x1>
     eaa:	e8 16       	cp	r14, r24
     eac:	f9 06       	cpc	r15, r25
     eae:	28 f4       	brcc	.+10     	; 0xeba <xTaskIncrementTick+0x78>
     eb0:	d1 2c       	mov	r13, r1
     eb2:	53 c0       	rjmp	.+166    	; 0xf5a <xTaskIncrementTick+0x118>
     eb4:	dd 24       	eor	r13, r13
     eb6:	d3 94       	inc	r13
     eb8:	01 c0       	rjmp	.+2      	; 0xebc <xTaskIncrementTick+0x7a>
     eba:	d1 2c       	mov	r13, r1
     ebc:	e0 91 f0 06 	lds	r30, 0x06F0	; 0x8006f0 <pxDelayedTaskList>
     ec0:	f0 91 f1 06 	lds	r31, 0x06F1	; 0x8006f1 <pxDelayedTaskList+0x1>
     ec4:	80 81       	ld	r24, Z
     ec6:	81 11       	cpse	r24, r1
     ec8:	07 c0       	rjmp	.+14     	; 0xed8 <xTaskIncrementTick+0x96>
     eca:	8f ef       	ldi	r24, 0xFF	; 255
     ecc:	9f ef       	ldi	r25, 0xFF	; 255
     ece:	90 93 c8 06 	sts	0x06C8, r25	; 0x8006c8 <xNextTaskUnblockTime+0x1>
     ed2:	80 93 c7 06 	sts	0x06C7, r24	; 0x8006c7 <xNextTaskUnblockTime>
     ed6:	41 c0       	rjmp	.+130    	; 0xf5a <xTaskIncrementTick+0x118>
     ed8:	e0 91 f0 06 	lds	r30, 0x06F0	; 0x8006f0 <pxDelayedTaskList>
     edc:	f0 91 f1 06 	lds	r31, 0x06F1	; 0x8006f1 <pxDelayedTaskList+0x1>
     ee0:	05 80       	ldd	r0, Z+5	; 0x05
     ee2:	f6 81       	ldd	r31, Z+6	; 0x06
     ee4:	e0 2d       	mov	r30, r0
     ee6:	c6 81       	ldd	r28, Z+6	; 0x06
     ee8:	d7 81       	ldd	r29, Z+7	; 0x07
     eea:	8a 81       	ldd	r24, Y+2	; 0x02
     eec:	9b 81       	ldd	r25, Y+3	; 0x03
     eee:	e8 16       	cp	r14, r24
     ef0:	f9 06       	cpc	r15, r25
     ef2:	28 f4       	brcc	.+10     	; 0xefe <xTaskIncrementTick+0xbc>
     ef4:	90 93 c8 06 	sts	0x06C8, r25	; 0x8006c8 <xNextTaskUnblockTime+0x1>
     ef8:	80 93 c7 06 	sts	0x06C7, r24	; 0x8006c7 <xNextTaskUnblockTime>
     efc:	2e c0       	rjmp	.+92     	; 0xf5a <xTaskIncrementTick+0x118>
     efe:	8e 01       	movw	r16, r28
     f00:	0e 5f       	subi	r16, 0xFE	; 254
     f02:	1f 4f       	sbci	r17, 0xFF	; 255
     f04:	c8 01       	movw	r24, r16
     f06:	0e 94 e3 00 	call	0x1c6	; 0x1c6 <uxListRemove>
     f0a:	8c 89       	ldd	r24, Y+20	; 0x14
     f0c:	9d 89       	ldd	r25, Y+21	; 0x15
     f0e:	89 2b       	or	r24, r25
     f10:	21 f0       	breq	.+8      	; 0xf1a <xTaskIncrementTick+0xd8>
     f12:	ce 01       	movw	r24, r28
     f14:	0c 96       	adiw	r24, 0x0c	; 12
     f16:	0e 94 e3 00 	call	0x1c6	; 0x1c6 <uxListRemove>
     f1a:	8e 89       	ldd	r24, Y+22	; 0x16
     f1c:	90 91 ce 06 	lds	r25, 0x06CE	; 0x8006ce <uxTopReadyPriority>
     f20:	98 17       	cp	r25, r24
     f22:	10 f4       	brcc	.+4      	; 0xf28 <xTaskIncrementTick+0xe6>
     f24:	80 93 ce 06 	sts	0x06CE, r24	; 0x8006ce <uxTopReadyPriority>
     f28:	90 e0       	ldi	r25, 0x00	; 0
     f2a:	9c 01       	movw	r18, r24
     f2c:	22 0f       	add	r18, r18
     f2e:	33 1f       	adc	r19, r19
     f30:	22 0f       	add	r18, r18
     f32:	33 1f       	adc	r19, r19
     f34:	22 0f       	add	r18, r18
     f36:	33 1f       	adc	r19, r19
     f38:	82 0f       	add	r24, r18
     f3a:	93 1f       	adc	r25, r19
     f3c:	b8 01       	movw	r22, r16
     f3e:	8c 5f       	subi	r24, 0xFC	; 252
     f40:	98 4f       	sbci	r25, 0xF8	; 248
     f42:	0e 94 91 00 	call	0x122	; 0x122 <vListInsertEnd>
     f46:	9e 89       	ldd	r25, Y+22	; 0x16
     f48:	e0 91 4c 07 	lds	r30, 0x074C	; 0x80074c <pxCurrentTCB>
     f4c:	f0 91 4d 07 	lds	r31, 0x074D	; 0x80074d <pxCurrentTCB+0x1>
     f50:	86 89       	ldd	r24, Z+22	; 0x16
     f52:	98 17       	cp	r25, r24
     f54:	08 f0       	brcs	.+2      	; 0xf58 <xTaskIncrementTick+0x116>
     f56:	ae cf       	rjmp	.-164    	; 0xeb4 <xTaskIncrementTick+0x72>
     f58:	b1 cf       	rjmp	.-158    	; 0xebc <xTaskIncrementTick+0x7a>
     f5a:	e0 91 4c 07 	lds	r30, 0x074C	; 0x80074c <pxCurrentTCB>
     f5e:	f0 91 4d 07 	lds	r31, 0x074D	; 0x80074d <pxCurrentTCB+0x1>
     f62:	86 89       	ldd	r24, Z+22	; 0x16
     f64:	90 e0       	ldi	r25, 0x00	; 0
     f66:	fc 01       	movw	r30, r24
     f68:	ee 0f       	add	r30, r30
     f6a:	ff 1f       	adc	r31, r31
     f6c:	ee 0f       	add	r30, r30
     f6e:	ff 1f       	adc	r31, r31
     f70:	ee 0f       	add	r30, r30
     f72:	ff 1f       	adc	r31, r31
     f74:	8e 0f       	add	r24, r30
     f76:	9f 1f       	adc	r25, r31
     f78:	fc 01       	movw	r30, r24
     f7a:	ec 5f       	subi	r30, 0xFC	; 252
     f7c:	f8 4f       	sbci	r31, 0xF8	; 248
     f7e:	80 81       	ld	r24, Z
     f80:	82 30       	cpi	r24, 0x02	; 2
     f82:	40 f4       	brcc	.+16     	; 0xf94 <xTaskIncrementTick+0x152>
     f84:	09 c0       	rjmp	.+18     	; 0xf98 <xTaskIncrementTick+0x156>
     f86:	80 91 cc 06 	lds	r24, 0x06CC	; 0x8006cc <uxPendedTicks>
     f8a:	8f 5f       	subi	r24, 0xFF	; 255
     f8c:	80 93 cc 06 	sts	0x06CC, r24	; 0x8006cc <uxPendedTicks>
     f90:	d1 2c       	mov	r13, r1
     f92:	02 c0       	rjmp	.+4      	; 0xf98 <xTaskIncrementTick+0x156>
     f94:	dd 24       	eor	r13, r13
     f96:	d3 94       	inc	r13
     f98:	80 91 cb 06 	lds	r24, 0x06CB	; 0x8006cb <xYieldPending>
     f9c:	88 23       	and	r24, r24
     f9e:	11 f0       	breq	.+4      	; 0xfa4 <xTaskIncrementTick+0x162>
     fa0:	dd 24       	eor	r13, r13
     fa2:	d3 94       	inc	r13
     fa4:	8d 2d       	mov	r24, r13
     fa6:	df 91       	pop	r29
     fa8:	cf 91       	pop	r28
     faa:	1f 91       	pop	r17
     fac:	0f 91       	pop	r16
     fae:	ff 90       	pop	r15
     fb0:	ef 90       	pop	r14
     fb2:	df 90       	pop	r13
     fb4:	08 95       	ret

00000fb6 <xTaskResumeAll>:
     fb6:	0f 93       	push	r16
     fb8:	1f 93       	push	r17
     fba:	cf 93       	push	r28
     fbc:	df 93       	push	r29
     fbe:	0f b6       	in	r0, 0x3f	; 63
     fc0:	f8 94       	cli
     fc2:	0f 92       	push	r0
     fc4:	80 91 c4 06 	lds	r24, 0x06C4	; 0x8006c4 <uxSchedulerSuspended>
     fc8:	81 50       	subi	r24, 0x01	; 1
     fca:	80 93 c4 06 	sts	0x06C4, r24	; 0x8006c4 <uxSchedulerSuspended>
     fce:	80 91 c4 06 	lds	r24, 0x06C4	; 0x8006c4 <uxSchedulerSuspended>
     fd2:	81 11       	cpse	r24, r1
     fd4:	58 c0       	rjmp	.+176    	; 0x1086 <xTaskResumeAll+0xd0>
     fd6:	80 91 d1 06 	lds	r24, 0x06D1	; 0x8006d1 <uxCurrentNumberOfTasks>
     fda:	81 11       	cpse	r24, r1
     fdc:	33 c0       	rjmp	.+102    	; 0x1044 <xTaskResumeAll+0x8e>
     fde:	56 c0       	rjmp	.+172    	; 0x108c <xTaskResumeAll+0xd6>
     fe0:	e0 91 ea 06 	lds	r30, 0x06EA	; 0x8006ea <xPendingReadyList+0x5>
     fe4:	f0 91 eb 06 	lds	r31, 0x06EB	; 0x8006eb <xPendingReadyList+0x6>
     fe8:	c6 81       	ldd	r28, Z+6	; 0x06
     fea:	d7 81       	ldd	r29, Z+7	; 0x07
     fec:	ce 01       	movw	r24, r28
     fee:	0c 96       	adiw	r24, 0x0c	; 12
     ff0:	0e 94 e3 00 	call	0x1c6	; 0x1c6 <uxListRemove>
     ff4:	8e 01       	movw	r16, r28
     ff6:	0e 5f       	subi	r16, 0xFE	; 254
     ff8:	1f 4f       	sbci	r17, 0xFF	; 255
     ffa:	c8 01       	movw	r24, r16
     ffc:	0e 94 e3 00 	call	0x1c6	; 0x1c6 <uxListRemove>
    1000:	8e 89       	ldd	r24, Y+22	; 0x16
    1002:	90 91 ce 06 	lds	r25, 0x06CE	; 0x8006ce <uxTopReadyPriority>
    1006:	98 17       	cp	r25, r24
    1008:	10 f4       	brcc	.+4      	; 0x100e <xTaskResumeAll+0x58>
    100a:	80 93 ce 06 	sts	0x06CE, r24	; 0x8006ce <uxTopReadyPriority>
    100e:	90 e0       	ldi	r25, 0x00	; 0
    1010:	9c 01       	movw	r18, r24
    1012:	22 0f       	add	r18, r18
    1014:	33 1f       	adc	r19, r19
    1016:	22 0f       	add	r18, r18
    1018:	33 1f       	adc	r19, r19
    101a:	22 0f       	add	r18, r18
    101c:	33 1f       	adc	r19, r19
    101e:	82 0f       	add	r24, r18
    1020:	93 1f       	adc	r25, r19
    1022:	b8 01       	movw	r22, r16
    1024:	8c 5f       	subi	r24, 0xFC	; 252
    1026:	98 4f       	sbci	r25, 0xF8	; 248
    1028:	0e 94 91 00 	call	0x122	; 0x122 <vListInsertEnd>
    102c:	9e 89       	ldd	r25, Y+22	; 0x16
    102e:	e0 91 4c 07 	lds	r30, 0x074C	; 0x80074c <pxCurrentTCB>
    1032:	f0 91 4d 07 	lds	r31, 0x074D	; 0x80074d <pxCurrentTCB+0x1>
    1036:	86 89       	ldd	r24, Z+22	; 0x16
    1038:	98 17       	cp	r25, r24
    103a:	30 f0       	brcs	.+12     	; 0x1048 <xTaskResumeAll+0x92>
    103c:	81 e0       	ldi	r24, 0x01	; 1
    103e:	80 93 cb 06 	sts	0x06CB, r24	; 0x8006cb <xYieldPending>
    1042:	02 c0       	rjmp	.+4      	; 0x1048 <xTaskResumeAll+0x92>
    1044:	c0 e0       	ldi	r28, 0x00	; 0
    1046:	d0 e0       	ldi	r29, 0x00	; 0
    1048:	80 91 e5 06 	lds	r24, 0x06E5	; 0x8006e5 <xPendingReadyList>
    104c:	81 11       	cpse	r24, r1
    104e:	c8 cf       	rjmp	.-112    	; 0xfe0 <xTaskResumeAll+0x2a>
    1050:	cd 2b       	or	r28, r29
    1052:	11 f0       	breq	.+4      	; 0x1058 <xTaskResumeAll+0xa2>
    1054:	0e 94 ea 04 	call	0x9d4	; 0x9d4 <prvResetNextTaskUnblockTime>
    1058:	c0 91 cc 06 	lds	r28, 0x06CC	; 0x8006cc <uxPendedTicks>
    105c:	cc 23       	and	r28, r28
    105e:	59 f0       	breq	.+22     	; 0x1076 <xTaskResumeAll+0xc0>
    1060:	0e 94 21 07 	call	0xe42	; 0xe42 <xTaskIncrementTick>
    1064:	88 23       	and	r24, r24
    1066:	19 f0       	breq	.+6      	; 0x106e <xTaskResumeAll+0xb8>
    1068:	81 e0       	ldi	r24, 0x01	; 1
    106a:	80 93 cb 06 	sts	0x06CB, r24	; 0x8006cb <xYieldPending>
    106e:	c1 50       	subi	r28, 0x01	; 1
    1070:	b9 f7       	brne	.-18     	; 0x1060 <xTaskResumeAll+0xaa>
    1072:	10 92 cc 06 	sts	0x06CC, r1	; 0x8006cc <uxPendedTicks>
    1076:	80 91 cb 06 	lds	r24, 0x06CB	; 0x8006cb <xYieldPending>
    107a:	88 23       	and	r24, r24
    107c:	31 f0       	breq	.+12     	; 0x108a <xTaskResumeAll+0xd4>
    107e:	0e 94 ae 01 	call	0x35c	; 0x35c <vPortYield>
    1082:	81 e0       	ldi	r24, 0x01	; 1
    1084:	03 c0       	rjmp	.+6      	; 0x108c <xTaskResumeAll+0xd6>
    1086:	80 e0       	ldi	r24, 0x00	; 0
    1088:	01 c0       	rjmp	.+2      	; 0x108c <xTaskResumeAll+0xd6>
    108a:	80 e0       	ldi	r24, 0x00	; 0
    108c:	0f 90       	pop	r0
    108e:	0f be       	out	0x3f, r0	; 63
    1090:	df 91       	pop	r29
    1092:	cf 91       	pop	r28
    1094:	1f 91       	pop	r17
    1096:	0f 91       	pop	r16
    1098:	08 95       	ret

0000109a <vTaskDelay>:
    109a:	cf 93       	push	r28
    109c:	df 93       	push	r29
    109e:	ec 01       	movw	r28, r24
    10a0:	89 2b       	or	r24, r25
    10a2:	49 f0       	breq	.+18     	; 0x10b6 <vTaskDelay+0x1c>
    10a4:	0e 94 1b 07 	call	0xe36	; 0xe36 <vTaskSuspendAll>
    10a8:	60 e0       	ldi	r22, 0x00	; 0
    10aa:	ce 01       	movw	r24, r28
    10ac:	0e 94 45 06 	call	0xc8a	; 0xc8a <prvAddCurrentTaskToDelayedList>
    10b0:	0e 94 db 07 	call	0xfb6	; 0xfb6 <xTaskResumeAll>
    10b4:	01 c0       	rjmp	.+2      	; 0x10b8 <vTaskDelay+0x1e>
    10b6:	80 e0       	ldi	r24, 0x00	; 0
    10b8:	81 11       	cpse	r24, r1
    10ba:	02 c0       	rjmp	.+4      	; 0x10c0 <vTaskDelay+0x26>
    10bc:	0e 94 ae 01 	call	0x35c	; 0x35c <vPortYield>
    10c0:	df 91       	pop	r29
    10c2:	cf 91       	pop	r28
    10c4:	08 95       	ret

000010c6 <vTaskSwitchContext>:
    10c6:	80 91 c4 06 	lds	r24, 0x06C4	; 0x8006c4 <uxSchedulerSuspended>
    10ca:	88 23       	and	r24, r24
    10cc:	21 f0       	breq	.+8      	; 0x10d6 <vTaskSwitchContext+0x10>
    10ce:	81 e0       	ldi	r24, 0x01	; 1
    10d0:	80 93 cb 06 	sts	0x06CB, r24	; 0x8006cb <xYieldPending>
    10d4:	08 95       	ret
    10d6:	10 92 cb 06 	sts	0x06CB, r1	; 0x8006cb <xYieldPending>
    10da:	20 91 ce 06 	lds	r18, 0x06CE	; 0x8006ce <uxTopReadyPriority>
    10de:	01 c0       	rjmp	.+2      	; 0x10e2 <vTaskSwitchContext+0x1c>
    10e0:	21 50       	subi	r18, 0x01	; 1
    10e2:	82 2f       	mov	r24, r18
    10e4:	90 e0       	ldi	r25, 0x00	; 0
    10e6:	fc 01       	movw	r30, r24
    10e8:	ee 0f       	add	r30, r30
    10ea:	ff 1f       	adc	r31, r31
    10ec:	ee 0f       	add	r30, r30
    10ee:	ff 1f       	adc	r31, r31
    10f0:	ee 0f       	add	r30, r30
    10f2:	ff 1f       	adc	r31, r31
    10f4:	e8 0f       	add	r30, r24
    10f6:	f9 1f       	adc	r31, r25
    10f8:	ec 5f       	subi	r30, 0xFC	; 252
    10fa:	f8 4f       	sbci	r31, 0xF8	; 248
    10fc:	30 81       	ld	r19, Z
    10fe:	33 23       	and	r19, r19
    1100:	79 f3       	breq	.-34     	; 0x10e0 <vTaskSwitchContext+0x1a>
    1102:	ac 01       	movw	r20, r24
    1104:	44 0f       	add	r20, r20
    1106:	55 1f       	adc	r21, r21
    1108:	44 0f       	add	r20, r20
    110a:	55 1f       	adc	r21, r21
    110c:	44 0f       	add	r20, r20
    110e:	55 1f       	adc	r21, r21
    1110:	48 0f       	add	r20, r24
    1112:	59 1f       	adc	r21, r25
    1114:	df 01       	movw	r26, r30
    1116:	01 80       	ldd	r0, Z+1	; 0x01
    1118:	f2 81       	ldd	r31, Z+2	; 0x02
    111a:	e0 2d       	mov	r30, r0
    111c:	02 80       	ldd	r0, Z+2	; 0x02
    111e:	f3 81       	ldd	r31, Z+3	; 0x03
    1120:	e0 2d       	mov	r30, r0
    1122:	12 96       	adiw	r26, 0x02	; 2
    1124:	fc 93       	st	X, r31
    1126:	ee 93       	st	-X, r30
    1128:	11 97       	sbiw	r26, 0x01	; 1
    112a:	49 5f       	subi	r20, 0xF9	; 249
    112c:	58 4f       	sbci	r21, 0xF8	; 248
    112e:	e4 17       	cp	r30, r20
    1130:	f5 07       	cpc	r31, r21
    1132:	29 f4       	brne	.+10     	; 0x113e <vTaskSwitchContext+0x78>
    1134:	42 81       	ldd	r20, Z+2	; 0x02
    1136:	53 81       	ldd	r21, Z+3	; 0x03
    1138:	fd 01       	movw	r30, r26
    113a:	52 83       	std	Z+2, r21	; 0x02
    113c:	41 83       	std	Z+1, r20	; 0x01
    113e:	fc 01       	movw	r30, r24
    1140:	ee 0f       	add	r30, r30
    1142:	ff 1f       	adc	r31, r31
    1144:	ee 0f       	add	r30, r30
    1146:	ff 1f       	adc	r31, r31
    1148:	ee 0f       	add	r30, r30
    114a:	ff 1f       	adc	r31, r31
    114c:	8e 0f       	add	r24, r30
    114e:	9f 1f       	adc	r25, r31
    1150:	fc 01       	movw	r30, r24
    1152:	ec 5f       	subi	r30, 0xFC	; 252
    1154:	f8 4f       	sbci	r31, 0xF8	; 248
    1156:	01 80       	ldd	r0, Z+1	; 0x01
    1158:	f2 81       	ldd	r31, Z+2	; 0x02
    115a:	e0 2d       	mov	r30, r0
    115c:	86 81       	ldd	r24, Z+6	; 0x06
    115e:	97 81       	ldd	r25, Z+7	; 0x07
    1160:	90 93 4d 07 	sts	0x074D, r25	; 0x80074d <pxCurrentTCB+0x1>
    1164:	80 93 4c 07 	sts	0x074C, r24	; 0x80074c <pxCurrentTCB>
    1168:	20 93 ce 06 	sts	0x06CE, r18	; 0x8006ce <uxTopReadyPriority>
    116c:	08 95       	ret

0000116e <vTaskPlaceOnEventList>:
    116e:	cf 93       	push	r28
    1170:	df 93       	push	r29
    1172:	eb 01       	movw	r28, r22
    1174:	60 91 4c 07 	lds	r22, 0x074C	; 0x80074c <pxCurrentTCB>
    1178:	70 91 4d 07 	lds	r23, 0x074D	; 0x80074d <pxCurrentTCB+0x1>
    117c:	64 5f       	subi	r22, 0xF4	; 244
    117e:	7f 4f       	sbci	r23, 0xFF	; 255
    1180:	0e 94 b2 00 	call	0x164	; 0x164 <vListInsert>
    1184:	61 e0       	ldi	r22, 0x01	; 1
    1186:	ce 01       	movw	r24, r28
    1188:	0e 94 45 06 	call	0xc8a	; 0xc8a <prvAddCurrentTaskToDelayedList>
    118c:	df 91       	pop	r29
    118e:	cf 91       	pop	r28
    1190:	08 95       	ret

00001192 <xTaskRemoveFromEventList>:
    1192:	0f 93       	push	r16
    1194:	1f 93       	push	r17
    1196:	cf 93       	push	r28
    1198:	df 93       	push	r29
    119a:	dc 01       	movw	r26, r24
    119c:	15 96       	adiw	r26, 0x05	; 5
    119e:	ed 91       	ld	r30, X+
    11a0:	fc 91       	ld	r31, X
    11a2:	16 97       	sbiw	r26, 0x06	; 6
    11a4:	c6 81       	ldd	r28, Z+6	; 0x06
    11a6:	d7 81       	ldd	r29, Z+7	; 0x07
    11a8:	8e 01       	movw	r16, r28
    11aa:	04 5f       	subi	r16, 0xF4	; 244
    11ac:	1f 4f       	sbci	r17, 0xFF	; 255
    11ae:	c8 01       	movw	r24, r16
    11b0:	0e 94 e3 00 	call	0x1c6	; 0x1c6 <uxListRemove>
    11b4:	80 91 c4 06 	lds	r24, 0x06C4	; 0x8006c4 <uxSchedulerSuspended>
    11b8:	81 11       	cpse	r24, r1
    11ba:	1c c0       	rjmp	.+56     	; 0x11f4 <xTaskRemoveFromEventList+0x62>
    11bc:	0a 50       	subi	r16, 0x0A	; 10
    11be:	11 09       	sbc	r17, r1
    11c0:	c8 01       	movw	r24, r16
    11c2:	0e 94 e3 00 	call	0x1c6	; 0x1c6 <uxListRemove>
    11c6:	8e 89       	ldd	r24, Y+22	; 0x16
    11c8:	90 91 ce 06 	lds	r25, 0x06CE	; 0x8006ce <uxTopReadyPriority>
    11cc:	98 17       	cp	r25, r24
    11ce:	10 f4       	brcc	.+4      	; 0x11d4 <xTaskRemoveFromEventList+0x42>
    11d0:	80 93 ce 06 	sts	0x06CE, r24	; 0x8006ce <uxTopReadyPriority>
    11d4:	90 e0       	ldi	r25, 0x00	; 0
    11d6:	9c 01       	movw	r18, r24
    11d8:	22 0f       	add	r18, r18
    11da:	33 1f       	adc	r19, r19
    11dc:	22 0f       	add	r18, r18
    11de:	33 1f       	adc	r19, r19
    11e0:	22 0f       	add	r18, r18
    11e2:	33 1f       	adc	r19, r19
    11e4:	82 0f       	add	r24, r18
    11e6:	93 1f       	adc	r25, r19
    11e8:	b8 01       	movw	r22, r16
    11ea:	8c 5f       	subi	r24, 0xFC	; 252
    11ec:	98 4f       	sbci	r25, 0xF8	; 248
    11ee:	0e 94 91 00 	call	0x122	; 0x122 <vListInsertEnd>
    11f2:	05 c0       	rjmp	.+10     	; 0x11fe <xTaskRemoveFromEventList+0x6c>
    11f4:	b8 01       	movw	r22, r16
    11f6:	85 ee       	ldi	r24, 0xE5	; 229
    11f8:	96 e0       	ldi	r25, 0x06	; 6
    11fa:	0e 94 91 00 	call	0x122	; 0x122 <vListInsertEnd>
    11fe:	9e 89       	ldd	r25, Y+22	; 0x16
    1200:	e0 91 4c 07 	lds	r30, 0x074C	; 0x80074c <pxCurrentTCB>
    1204:	f0 91 4d 07 	lds	r31, 0x074D	; 0x80074d <pxCurrentTCB+0x1>
    1208:	86 89       	ldd	r24, Z+22	; 0x16
    120a:	89 17       	cp	r24, r25
    120c:	20 f4       	brcc	.+8      	; 0x1216 <xTaskRemoveFromEventList+0x84>
    120e:	81 e0       	ldi	r24, 0x01	; 1
    1210:	80 93 cb 06 	sts	0x06CB, r24	; 0x8006cb <xYieldPending>
    1214:	01 c0       	rjmp	.+2      	; 0x1218 <xTaskRemoveFromEventList+0x86>
    1216:	80 e0       	ldi	r24, 0x00	; 0
    1218:	df 91       	pop	r29
    121a:	cf 91       	pop	r28
    121c:	1f 91       	pop	r17
    121e:	0f 91       	pop	r16
    1220:	08 95       	ret

00001222 <vTaskInternalSetTimeOutState>:
    1222:	20 91 ca 06 	lds	r18, 0x06CA	; 0x8006ca <xNumOfOverflows>
    1226:	fc 01       	movw	r30, r24
    1228:	20 83       	st	Z, r18
    122a:	20 91 cf 06 	lds	r18, 0x06CF	; 0x8006cf <xTickCount>
    122e:	30 91 d0 06 	lds	r19, 0x06D0	; 0x8006d0 <xTickCount+0x1>
    1232:	32 83       	std	Z+2, r19	; 0x02
    1234:	21 83       	std	Z+1, r18	; 0x01
    1236:	08 95       	ret

00001238 <xTaskCheckForTimeOut>:
    1238:	1f 93       	push	r17
    123a:	cf 93       	push	r28
    123c:	df 93       	push	r29
    123e:	0f b6       	in	r0, 0x3f	; 63
    1240:	f8 94       	cli
    1242:	0f 92       	push	r0
    1244:	e0 91 cf 06 	lds	r30, 0x06CF	; 0x8006cf <xTickCount>
    1248:	f0 91 d0 06 	lds	r31, 0x06D0	; 0x8006d0 <xTickCount+0x1>
    124c:	dc 01       	movw	r26, r24
    124e:	11 96       	adiw	r26, 0x01	; 1
    1250:	4d 91       	ld	r20, X+
    1252:	5c 91       	ld	r21, X
    1254:	12 97       	sbiw	r26, 0x02	; 2
    1256:	df 01       	movw	r26, r30
    1258:	a4 1b       	sub	r26, r20
    125a:	b5 0b       	sbc	r27, r21
    125c:	eb 01       	movw	r28, r22
    125e:	28 81       	ld	r18, Y
    1260:	39 81       	ldd	r19, Y+1	; 0x01
    1262:	2f 3f       	cpi	r18, 0xFF	; 255
    1264:	df ef       	ldi	r29, 0xFF	; 255
    1266:	3d 07       	cpc	r19, r29
    1268:	d1 f0       	breq	.+52     	; 0x129e <xTaskCheckForTimeOut+0x66>
    126a:	ec 01       	movw	r28, r24
    126c:	18 81       	ld	r17, Y
    126e:	c0 91 ca 06 	lds	r28, 0x06CA	; 0x8006ca <xNumOfOverflows>
    1272:	1c 17       	cp	r17, r28
    1274:	19 f0       	breq	.+6      	; 0x127c <xTaskCheckForTimeOut+0x44>
    1276:	e4 17       	cp	r30, r20
    1278:	f5 07       	cpc	r31, r21
    127a:	98 f4       	brcc	.+38     	; 0x12a2 <xTaskCheckForTimeOut+0x6a>
    127c:	a2 17       	cp	r26, r18
    127e:	b3 07       	cpc	r27, r19
    1280:	48 f4       	brcc	.+18     	; 0x1294 <xTaskCheckForTimeOut+0x5c>
    1282:	fb 01       	movw	r30, r22
    1284:	2a 1b       	sub	r18, r26
    1286:	3b 0b       	sbc	r19, r27
    1288:	31 83       	std	Z+1, r19	; 0x01
    128a:	20 83       	st	Z, r18
    128c:	0e 94 11 09 	call	0x1222	; 0x1222 <vTaskInternalSetTimeOutState>
    1290:	80 e0       	ldi	r24, 0x00	; 0
    1292:	08 c0       	rjmp	.+16     	; 0x12a4 <xTaskCheckForTimeOut+0x6c>
    1294:	fb 01       	movw	r30, r22
    1296:	11 82       	std	Z+1, r1	; 0x01
    1298:	10 82       	st	Z, r1
    129a:	81 e0       	ldi	r24, 0x01	; 1
    129c:	03 c0       	rjmp	.+6      	; 0x12a4 <xTaskCheckForTimeOut+0x6c>
    129e:	80 e0       	ldi	r24, 0x00	; 0
    12a0:	01 c0       	rjmp	.+2      	; 0x12a4 <xTaskCheckForTimeOut+0x6c>
    12a2:	81 e0       	ldi	r24, 0x01	; 1
    12a4:	0f 90       	pop	r0
    12a6:	0f be       	out	0x3f, r0	; 63
    12a8:	df 91       	pop	r29
    12aa:	cf 91       	pop	r28
    12ac:	1f 91       	pop	r17
    12ae:	08 95       	ret

000012b0 <vTaskMissedYield>:
    12b0:	81 e0       	ldi	r24, 0x01	; 1
    12b2:	80 93 cb 06 	sts	0x06CB, r24	; 0x8006cb <xYieldPending>
    12b6:	08 95       	ret

000012b8 <xTaskPriorityInherit>:
    12b8:	0f 93       	push	r16
    12ba:	1f 93       	push	r17
    12bc:	cf 93       	push	r28
    12be:	df 93       	push	r29
    12c0:	fc 01       	movw	r30, r24
    12c2:	89 2b       	or	r24, r25
    12c4:	09 f4       	brne	.+2      	; 0x12c8 <xTaskPriorityInherit+0x10>
    12c6:	62 c0       	rjmp	.+196    	; 0x138c <xTaskPriorityInherit+0xd4>
    12c8:	26 89       	ldd	r18, Z+22	; 0x16
    12ca:	a0 91 4c 07 	lds	r26, 0x074C	; 0x80074c <pxCurrentTCB>
    12ce:	b0 91 4d 07 	lds	r27, 0x074D	; 0x80074d <pxCurrentTCB+0x1>
    12d2:	56 96       	adiw	r26, 0x16	; 22
    12d4:	8c 91       	ld	r24, X
    12d6:	28 17       	cp	r18, r24
    12d8:	08 f0       	brcs	.+2      	; 0x12dc <xTaskPriorityInherit+0x24>
    12da:	4e c0       	rjmp	.+156    	; 0x1378 <xTaskPriorityInherit+0xc0>
    12dc:	84 85       	ldd	r24, Z+12	; 0x0c
    12de:	95 85       	ldd	r25, Z+13	; 0x0d
    12e0:	99 23       	and	r25, r25
    12e2:	64 f0       	brlt	.+24     	; 0x12fc <xTaskPriorityInherit+0x44>
    12e4:	a0 91 4c 07 	lds	r26, 0x074C	; 0x80074c <pxCurrentTCB>
    12e8:	b0 91 4d 07 	lds	r27, 0x074D	; 0x80074d <pxCurrentTCB+0x1>
    12ec:	56 96       	adiw	r26, 0x16	; 22
    12ee:	3c 91       	ld	r19, X
    12f0:	88 e0       	ldi	r24, 0x08	; 8
    12f2:	90 e0       	ldi	r25, 0x00	; 0
    12f4:	83 1b       	sub	r24, r19
    12f6:	91 09       	sbc	r25, r1
    12f8:	95 87       	std	Z+13, r25	; 0x0d
    12fa:	84 87       	std	Z+12, r24	; 0x0c
    12fc:	82 85       	ldd	r24, Z+10	; 0x0a
    12fe:	93 85       	ldd	r25, Z+11	; 0x0b
    1300:	30 e0       	ldi	r19, 0x00	; 0
    1302:	a9 01       	movw	r20, r18
    1304:	44 0f       	add	r20, r20
    1306:	55 1f       	adc	r21, r21
    1308:	44 0f       	add	r20, r20
    130a:	55 1f       	adc	r21, r21
    130c:	44 0f       	add	r20, r20
    130e:	55 1f       	adc	r21, r21
    1310:	24 0f       	add	r18, r20
    1312:	35 1f       	adc	r19, r21
    1314:	2c 5f       	subi	r18, 0xFC	; 252
    1316:	38 4f       	sbci	r19, 0xF8	; 248
    1318:	82 17       	cp	r24, r18
    131a:	93 07       	cpc	r25, r19
    131c:	21 f5       	brne	.+72     	; 0x1366 <xTaskPriorityInherit+0xae>
    131e:	8f 01       	movw	r16, r30
    1320:	ef 01       	movw	r28, r30
    1322:	22 96       	adiw	r28, 0x02	; 2
    1324:	ce 01       	movw	r24, r28
    1326:	0e 94 e3 00 	call	0x1c6	; 0x1c6 <uxListRemove>
    132a:	e0 91 4c 07 	lds	r30, 0x074C	; 0x80074c <pxCurrentTCB>
    132e:	f0 91 4d 07 	lds	r31, 0x074D	; 0x80074d <pxCurrentTCB+0x1>
    1332:	86 89       	ldd	r24, Z+22	; 0x16
    1334:	f8 01       	movw	r30, r16
    1336:	86 8b       	std	Z+22, r24	; 0x16
    1338:	90 91 ce 06 	lds	r25, 0x06CE	; 0x8006ce <uxTopReadyPriority>
    133c:	98 17       	cp	r25, r24
    133e:	10 f4       	brcc	.+4      	; 0x1344 <xTaskPriorityInherit+0x8c>
    1340:	80 93 ce 06 	sts	0x06CE, r24	; 0x8006ce <uxTopReadyPriority>
    1344:	90 e0       	ldi	r25, 0x00	; 0
    1346:	9c 01       	movw	r18, r24
    1348:	22 0f       	add	r18, r18
    134a:	33 1f       	adc	r19, r19
    134c:	22 0f       	add	r18, r18
    134e:	33 1f       	adc	r19, r19
    1350:	22 0f       	add	r18, r18
    1352:	33 1f       	adc	r19, r19
    1354:	82 0f       	add	r24, r18
    1356:	93 1f       	adc	r25, r19
    1358:	be 01       	movw	r22, r28
    135a:	8c 5f       	subi	r24, 0xFC	; 252
    135c:	98 4f       	sbci	r25, 0xF8	; 248
    135e:	0e 94 91 00 	call	0x122	; 0x122 <vListInsertEnd>
    1362:	81 e0       	ldi	r24, 0x01	; 1
    1364:	16 c0       	rjmp	.+44     	; 0x1392 <xTaskPriorityInherit+0xda>
    1366:	a0 91 4c 07 	lds	r26, 0x074C	; 0x80074c <pxCurrentTCB>
    136a:	b0 91 4d 07 	lds	r27, 0x074D	; 0x80074d <pxCurrentTCB+0x1>
    136e:	56 96       	adiw	r26, 0x16	; 22
    1370:	8c 91       	ld	r24, X
    1372:	86 8b       	std	Z+22, r24	; 0x16
    1374:	81 e0       	ldi	r24, 0x01	; 1
    1376:	0d c0       	rjmp	.+26     	; 0x1392 <xTaskPriorityInherit+0xda>
    1378:	91 a1       	ldd	r25, Z+33	; 0x21
    137a:	e0 91 4c 07 	lds	r30, 0x074C	; 0x80074c <pxCurrentTCB>
    137e:	f0 91 4d 07 	lds	r31, 0x074D	; 0x80074d <pxCurrentTCB+0x1>
    1382:	86 89       	ldd	r24, Z+22	; 0x16
    1384:	98 17       	cp	r25, r24
    1386:	20 f0       	brcs	.+8      	; 0x1390 <xTaskPriorityInherit+0xd8>
    1388:	80 e0       	ldi	r24, 0x00	; 0
    138a:	03 c0       	rjmp	.+6      	; 0x1392 <xTaskPriorityInherit+0xda>
    138c:	80 e0       	ldi	r24, 0x00	; 0
    138e:	01 c0       	rjmp	.+2      	; 0x1392 <xTaskPriorityInherit+0xda>
    1390:	81 e0       	ldi	r24, 0x01	; 1
    1392:	df 91       	pop	r29
    1394:	cf 91       	pop	r28
    1396:	1f 91       	pop	r17
    1398:	0f 91       	pop	r16
    139a:	08 95       	ret

0000139c <xTaskPriorityDisinherit>:
    139c:	0f 93       	push	r16
    139e:	1f 93       	push	r17
    13a0:	cf 93       	push	r28
    13a2:	df 93       	push	r29
    13a4:	fc 01       	movw	r30, r24
    13a6:	89 2b       	or	r24, r25
    13a8:	79 f1       	breq	.+94     	; 0x1408 <xTaskPriorityDisinherit+0x6c>
    13aa:	82 a1       	ldd	r24, Z+34	; 0x22
    13ac:	81 50       	subi	r24, 0x01	; 1
    13ae:	82 a3       	std	Z+34, r24	; 0x22
    13b0:	26 89       	ldd	r18, Z+22	; 0x16
    13b2:	91 a1       	ldd	r25, Z+33	; 0x21
    13b4:	29 17       	cp	r18, r25
    13b6:	51 f1       	breq	.+84     	; 0x140c <xTaskPriorityDisinherit+0x70>
    13b8:	81 11       	cpse	r24, r1
    13ba:	2a c0       	rjmp	.+84     	; 0x1410 <xTaskPriorityDisinherit+0x74>
    13bc:	ef 01       	movw	r28, r30
    13be:	8f 01       	movw	r16, r30
    13c0:	0e 5f       	subi	r16, 0xFE	; 254
    13c2:	1f 4f       	sbci	r17, 0xFF	; 255
    13c4:	c8 01       	movw	r24, r16
    13c6:	0e 94 e3 00 	call	0x1c6	; 0x1c6 <uxListRemove>
    13ca:	89 a1       	ldd	r24, Y+33	; 0x21
    13cc:	8e 8b       	std	Y+22, r24	; 0x16
    13ce:	28 e0       	ldi	r18, 0x08	; 8
    13d0:	30 e0       	ldi	r19, 0x00	; 0
    13d2:	28 1b       	sub	r18, r24
    13d4:	31 09       	sbc	r19, r1
    13d6:	3d 87       	std	Y+13, r19	; 0x0d
    13d8:	2c 87       	std	Y+12, r18	; 0x0c
    13da:	90 91 ce 06 	lds	r25, 0x06CE	; 0x8006ce <uxTopReadyPriority>
    13de:	98 17       	cp	r25, r24
    13e0:	10 f4       	brcc	.+4      	; 0x13e6 <xTaskPriorityDisinherit+0x4a>
    13e2:	80 93 ce 06 	sts	0x06CE, r24	; 0x8006ce <uxTopReadyPriority>
    13e6:	90 e0       	ldi	r25, 0x00	; 0
    13e8:	9c 01       	movw	r18, r24
    13ea:	22 0f       	add	r18, r18
    13ec:	33 1f       	adc	r19, r19
    13ee:	22 0f       	add	r18, r18
    13f0:	33 1f       	adc	r19, r19
    13f2:	22 0f       	add	r18, r18
    13f4:	33 1f       	adc	r19, r19
    13f6:	82 0f       	add	r24, r18
    13f8:	93 1f       	adc	r25, r19
    13fa:	b8 01       	movw	r22, r16
    13fc:	8c 5f       	subi	r24, 0xFC	; 252
    13fe:	98 4f       	sbci	r25, 0xF8	; 248
    1400:	0e 94 91 00 	call	0x122	; 0x122 <vListInsertEnd>
    1404:	81 e0       	ldi	r24, 0x01	; 1
    1406:	05 c0       	rjmp	.+10     	; 0x1412 <xTaskPriorityDisinherit+0x76>
    1408:	80 e0       	ldi	r24, 0x00	; 0
    140a:	03 c0       	rjmp	.+6      	; 0x1412 <xTaskPriorityDisinherit+0x76>
    140c:	80 e0       	ldi	r24, 0x00	; 0
    140e:	01 c0       	rjmp	.+2      	; 0x1412 <xTaskPriorityDisinherit+0x76>
    1410:	80 e0       	ldi	r24, 0x00	; 0
    1412:	df 91       	pop	r29
    1414:	cf 91       	pop	r28
    1416:	1f 91       	pop	r17
    1418:	0f 91       	pop	r16
    141a:	08 95       	ret

0000141c <vTaskPriorityDisinheritAfterTimeout>:
    141c:	0f 93       	push	r16
    141e:	1f 93       	push	r17
    1420:	cf 93       	push	r28
    1422:	df 93       	push	r29
    1424:	fc 01       	movw	r30, r24
    1426:	89 2b       	or	r24, r25
    1428:	09 f4       	brne	.+2      	; 0x142c <vTaskPriorityDisinheritAfterTimeout+0x10>
    142a:	43 c0       	rjmp	.+134    	; 0x14b2 <vTaskPriorityDisinheritAfterTimeout+0x96>
    142c:	91 a1       	ldd	r25, Z+33	; 0x21
    142e:	96 17       	cp	r25, r22
    1430:	08 f4       	brcc	.+2      	; 0x1434 <vTaskPriorityDisinheritAfterTimeout+0x18>
    1432:	96 2f       	mov	r25, r22
    1434:	86 89       	ldd	r24, Z+22	; 0x16
    1436:	98 17       	cp	r25, r24
    1438:	e1 f1       	breq	.+120    	; 0x14b2 <vTaskPriorityDisinheritAfterTimeout+0x96>
    143a:	22 a1       	ldd	r18, Z+34	; 0x22
    143c:	21 30       	cpi	r18, 0x01	; 1
    143e:	c9 f5       	brne	.+114    	; 0x14b2 <vTaskPriorityDisinheritAfterTimeout+0x96>
    1440:	96 8b       	std	Z+22, r25	; 0x16
    1442:	24 85       	ldd	r18, Z+12	; 0x0c
    1444:	35 85       	ldd	r19, Z+13	; 0x0d
    1446:	33 23       	and	r19, r19
    1448:	34 f0       	brlt	.+12     	; 0x1456 <vTaskPriorityDisinheritAfterTimeout+0x3a>
    144a:	28 e0       	ldi	r18, 0x08	; 8
    144c:	30 e0       	ldi	r19, 0x00	; 0
    144e:	29 1b       	sub	r18, r25
    1450:	31 09       	sbc	r19, r1
    1452:	35 87       	std	Z+13, r19	; 0x0d
    1454:	24 87       	std	Z+12, r18	; 0x0c
    1456:	22 85       	ldd	r18, Z+10	; 0x0a
    1458:	33 85       	ldd	r19, Z+11	; 0x0b
    145a:	90 e0       	ldi	r25, 0x00	; 0
    145c:	ac 01       	movw	r20, r24
    145e:	44 0f       	add	r20, r20
    1460:	55 1f       	adc	r21, r21
    1462:	44 0f       	add	r20, r20
    1464:	55 1f       	adc	r21, r21
    1466:	44 0f       	add	r20, r20
    1468:	55 1f       	adc	r21, r21
    146a:	84 0f       	add	r24, r20
    146c:	95 1f       	adc	r25, r21
    146e:	8c 5f       	subi	r24, 0xFC	; 252
    1470:	98 4f       	sbci	r25, 0xF8	; 248
    1472:	28 17       	cp	r18, r24
    1474:	39 07       	cpc	r19, r25
    1476:	e9 f4       	brne	.+58     	; 0x14b2 <vTaskPriorityDisinheritAfterTimeout+0x96>
    1478:	ef 01       	movw	r28, r30
    147a:	8f 01       	movw	r16, r30
    147c:	0e 5f       	subi	r16, 0xFE	; 254
    147e:	1f 4f       	sbci	r17, 0xFF	; 255
    1480:	c8 01       	movw	r24, r16
    1482:	0e 94 e3 00 	call	0x1c6	; 0x1c6 <uxListRemove>
    1486:	8e 89       	ldd	r24, Y+22	; 0x16
    1488:	90 91 ce 06 	lds	r25, 0x06CE	; 0x8006ce <uxTopReadyPriority>
    148c:	98 17       	cp	r25, r24
    148e:	10 f4       	brcc	.+4      	; 0x1494 <vTaskPriorityDisinheritAfterTimeout+0x78>
    1490:	80 93 ce 06 	sts	0x06CE, r24	; 0x8006ce <uxTopReadyPriority>
    1494:	90 e0       	ldi	r25, 0x00	; 0
    1496:	9c 01       	movw	r18, r24
    1498:	22 0f       	add	r18, r18
    149a:	33 1f       	adc	r19, r19
    149c:	22 0f       	add	r18, r18
    149e:	33 1f       	adc	r19, r19
    14a0:	22 0f       	add	r18, r18
    14a2:	33 1f       	adc	r19, r19
    14a4:	82 0f       	add	r24, r18
    14a6:	93 1f       	adc	r25, r19
    14a8:	b8 01       	movw	r22, r16
    14aa:	8c 5f       	subi	r24, 0xFC	; 252
    14ac:	98 4f       	sbci	r25, 0xF8	; 248
    14ae:	0e 94 91 00 	call	0x122	; 0x122 <vListInsertEnd>
    14b2:	df 91       	pop	r29
    14b4:	cf 91       	pop	r28
    14b6:	1f 91       	pop	r17
    14b8:	0f 91       	pop	r16
    14ba:	08 95       	ret

000014bc <pvTaskIncrementMutexHeldCount>:

	TaskHandle_t pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    14bc:	80 91 4c 07 	lds	r24, 0x074C	; 0x80074c <pxCurrentTCB>
    14c0:	90 91 4d 07 	lds	r25, 0x074D	; 0x80074d <pxCurrentTCB+0x1>
    14c4:	89 2b       	or	r24, r25
    14c6:	39 f0       	breq	.+14     	; 0x14d6 <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    14c8:	e0 91 4c 07 	lds	r30, 0x074C	; 0x80074c <pxCurrentTCB>
    14cc:	f0 91 4d 07 	lds	r31, 0x074D	; 0x80074d <pxCurrentTCB+0x1>
    14d0:	82 a1       	ldd	r24, Z+34	; 0x22
    14d2:	8f 5f       	subi	r24, 0xFF	; 255
    14d4:	82 a3       	std	Z+34, r24	; 0x22
		}

		return pxCurrentTCB;
    14d6:	80 91 4c 07 	lds	r24, 0x074C	; 0x80074c <pxCurrentTCB>
    14da:	90 91 4d 07 	lds	r25, 0x074D	; 0x80074d <pxCurrentTCB+0x1>
	}
    14de:	08 95       	ret

000014e0 <keypad_init>:
uint8 keypadmap[rows][cols]={{1,2,3,4},{5,6,7,8},{9,10,11,12},{13,14,15,16}};

void keypad_init()
{
	//row as output
	DDRD_REG|=(1<<0) | (1<<1)|(1<<2)|(1<<3);
    14e0:	81 b3       	in	r24, 0x11	; 17
    14e2:	8f 60       	ori	r24, 0x0F	; 15
    14e4:	81 bb       	out	0x11, r24	; 17
	//set the col input
	DDRD_REG&=~((1<<4) | (1<<5) | (1 << 6) | (1<<7));
    14e6:	81 b3       	in	r24, 0x11	; 17
    14e8:	8f 70       	andi	r24, 0x0F	; 15
    14ea:	81 bb       	out	0x11, r24	; 17
	//set col init high : pull up res
	PORTD_REG|=((1<<4) | (1<<5) | (1 << 6) | (1<<7));
    14ec:	82 b3       	in	r24, 0x12	; 18
    14ee:	80 6f       	ori	r24, 0xF0	; 240
    14f0:	82 bb       	out	0x12, r24	; 18
    14f2:	08 95       	ret

000014f4 <keypad_scan>:
}

uint8 keypad_scan()
{
    14f4:	cf 93       	push	r28
	uint8 i,j;
	for(i=0 ; i< rows ; i++)
    14f6:	c0 e0       	ldi	r28, 0x00	; 0
    14f8:	3d c0       	rjmp	.+122    	; 0x1574 <keypad_scan+0x80>
	{
		//activate the row 
		PORTD_REG&=~(1<<i);
    14fa:	82 b3       	in	r24, 0x12	; 18
    14fc:	6c 2f       	mov	r22, r28
    14fe:	70 e0       	ldi	r23, 0x00	; 0
    1500:	a1 e0       	ldi	r26, 0x01	; 1
    1502:	b0 e0       	ldi	r27, 0x00	; 0
    1504:	0c 2e       	mov	r0, r28
    1506:	02 c0       	rjmp	.+4      	; 0x150c <keypad_scan+0x18>
    1508:	aa 0f       	add	r26, r26
    150a:	bb 1f       	adc	r27, r27
    150c:	0a 94       	dec	r0
    150e:	e2 f7       	brpl	.-8      	; 0x1508 <keypad_scan+0x14>
    1510:	9a 2f       	mov	r25, r26
    1512:	90 95       	com	r25
    1514:	89 23       	and	r24, r25
    1516:	82 bb       	out	0x12, r24	; 18
		for(j=0;j<cols;j++)
    1518:	20 e0       	ldi	r18, 0x00	; 0
    151a:	26 c0       	rjmp	.+76     	; 0x1568 <keypad_scan+0x74>
		{
			if((PIND_REG&(1<<colpins[j]))==0)
    151c:	80 b3       	in	r24, 0x10	; 16
    151e:	42 2f       	mov	r20, r18
    1520:	50 e0       	ldi	r21, 0x00	; 0
    1522:	fa 01       	movw	r30, r20
    1524:	e0 59       	subi	r30, 0x90	; 144
    1526:	ff 4f       	sbci	r31, 0xFF	; 255
    1528:	30 81       	ld	r19, Z
    152a:	e3 2f       	mov	r30, r19
    152c:	90 e0       	ldi	r25, 0x00	; 0
    152e:	02 c0       	rjmp	.+4      	; 0x1534 <keypad_scan+0x40>
    1530:	95 95       	asr	r25
    1532:	87 95       	ror	r24
    1534:	3a 95       	dec	r19
    1536:	e2 f7       	brpl	.-8      	; 0x1530 <keypad_scan+0x3c>
    1538:	80 fd       	sbrc	r24, 0
    153a:	15 c0       	rjmp	.+42     	; 0x1566 <keypad_scan+0x72>
			{
				while((PIND_REG&(1<<colpins[j]))==0);
    153c:	80 b3       	in	r24, 0x10	; 16
    153e:	90 e0       	ldi	r25, 0x00	; 0
    1540:	0e 2e       	mov	r0, r30
    1542:	02 c0       	rjmp	.+4      	; 0x1548 <keypad_scan+0x54>
    1544:	95 95       	asr	r25
    1546:	87 95       	ror	r24
    1548:	0a 94       	dec	r0
    154a:	e2 f7       	brpl	.-8      	; 0x1544 <keypad_scan+0x50>
    154c:	80 ff       	sbrs	r24, 0
    154e:	f6 cf       	rjmp	.-20     	; 0x153c <keypad_scan+0x48>
				return keypadmap[i][j];
    1550:	66 0f       	add	r22, r22
    1552:	77 1f       	adc	r23, r23
    1554:	66 0f       	add	r22, r22
    1556:	77 1f       	adc	r23, r23
    1558:	60 5a       	subi	r22, 0xA0	; 160
    155a:	7f 4f       	sbci	r23, 0xFF	; 255
    155c:	fb 01       	movw	r30, r22
    155e:	e4 0f       	add	r30, r20
    1560:	f5 1f       	adc	r31, r21
    1562:	80 81       	ld	r24, Z
    1564:	0a c0       	rjmp	.+20     	; 0x157a <keypad_scan+0x86>
	uint8 i,j;
	for(i=0 ; i< rows ; i++)
	{
		//activate the row 
		PORTD_REG&=~(1<<i);
		for(j=0;j<cols;j++)
    1566:	2f 5f       	subi	r18, 0xFF	; 255
    1568:	24 30       	cpi	r18, 0x04	; 4
    156a:	c0 f2       	brcs	.-80     	; 0x151c <keypad_scan+0x28>
				while((PIND_REG&(1<<colpins[j]))==0);
				return keypadmap[i][j];
			}
		}
		//deactivate the current row 
		PORTD_REG|=(1<<i);
    156c:	82 b3       	in	r24, 0x12	; 18
    156e:	a8 2b       	or	r26, r24
    1570:	a2 bb       	out	0x12, r26	; 18
}

uint8 keypad_scan()
{
	uint8 i,j;
	for(i=0 ; i< rows ; i++)
    1572:	cf 5f       	subi	r28, 0xFF	; 255
    1574:	c4 30       	cpi	r28, 0x04	; 4
    1576:	08 f2       	brcs	.-126    	; 0x14fa <keypad_scan+0x6>
			}
		}
		//deactivate the current row 
		PORTD_REG|=(1<<i);
	}
	return 0;
    1578:	80 e0       	ldi	r24, 0x00	; 0
}
    157a:	cf 91       	pop	r28
    157c:	08 95       	ret

0000157e <Private_u16GetPower>:
void LCD_VoidIntgerToString (uint16 num)
{
	uint8 buff[16];
	itoa(num, buff, 10);
	LCD_sendString(buff);
}
    157e:	90 e0       	ldi	r25, 0x00	; 0
    1580:	21 e0       	ldi	r18, 0x01	; 1
    1582:	30 e0       	ldi	r19, 0x00	; 0
    1584:	07 c0       	rjmp	.+14     	; 0x1594 <Private_u16GetPower+0x16>
    1586:	a9 01       	movw	r20, r18
    1588:	84 9f       	mul	r24, r20
    158a:	90 01       	movw	r18, r0
    158c:	85 9f       	mul	r24, r21
    158e:	30 0d       	add	r19, r0
    1590:	11 24       	eor	r1, r1
    1592:	9f 5f       	subi	r25, 0xFF	; 255
    1594:	96 17       	cp	r25, r22
    1596:	b8 f3       	brcs	.-18     	; 0x1586 <Private_u16GetPower+0x8>
    1598:	c9 01       	movw	r24, r18
    159a:	08 95       	ret

0000159c <LCD_Send_Command>:
    159c:	cf 93       	push	r28
    159e:	c8 2f       	mov	r28, r24
    15a0:	40 e0       	ldi	r20, 0x00	; 0
    15a2:	65 e0       	ldi	r22, 0x05	; 5
    15a4:	82 e0       	ldi	r24, 0x02	; 2
    15a6:	0e 94 6d 0f 	call	0x1eda	; 0x1eda <DIO_set_pin_value>
    15aa:	40 e0       	ldi	r20, 0x00	; 0
    15ac:	64 e0       	ldi	r22, 0x04	; 4
    15ae:	82 e0       	ldi	r24, 0x02	; 2
    15b0:	0e 94 6d 0f 	call	0x1eda	; 0x1eda <DIO_set_pin_value>
    15b4:	6c 2f       	mov	r22, r28
    15b6:	81 e0       	ldi	r24, 0x01	; 1
    15b8:	0e 94 e6 0f 	call	0x1fcc	; 0x1fcc <DIO_set_port_char>
    15bc:	41 e0       	ldi	r20, 0x01	; 1
    15be:	63 e0       	ldi	r22, 0x03	; 3
    15c0:	82 e0       	ldi	r24, 0x02	; 2
    15c2:	0e 94 6d 0f 	call	0x1eda	; 0x1eda <DIO_set_pin_value>
    15c6:	83 ef       	ldi	r24, 0xF3	; 243
    15c8:	91 e0       	ldi	r25, 0x01	; 1
    15ca:	01 97       	sbiw	r24, 0x01	; 1
    15cc:	f1 f7       	brne	.-4      	; 0x15ca <LCD_Send_Command+0x2e>
    15ce:	00 c0       	rjmp	.+0      	; 0x15d0 <LCD_Send_Command+0x34>
    15d0:	00 00       	nop
    15d2:	40 e0       	ldi	r20, 0x00	; 0
    15d4:	63 e0       	ldi	r22, 0x03	; 3
    15d6:	82 e0       	ldi	r24, 0x02	; 2
    15d8:	0e 94 6d 0f 	call	0x1eda	; 0x1eda <DIO_set_pin_value>
    15dc:	cf 91       	pop	r28
    15de:	08 95       	ret

000015e0 <LCD_Send_Data>:
    15e0:	cf 93       	push	r28
    15e2:	c8 2f       	mov	r28, r24
    15e4:	41 e0       	ldi	r20, 0x01	; 1
    15e6:	65 e0       	ldi	r22, 0x05	; 5
    15e8:	82 e0       	ldi	r24, 0x02	; 2
    15ea:	0e 94 6d 0f 	call	0x1eda	; 0x1eda <DIO_set_pin_value>
    15ee:	40 e0       	ldi	r20, 0x00	; 0
    15f0:	64 e0       	ldi	r22, 0x04	; 4
    15f2:	82 e0       	ldi	r24, 0x02	; 2
    15f4:	0e 94 6d 0f 	call	0x1eda	; 0x1eda <DIO_set_pin_value>
    15f8:	6c 2f       	mov	r22, r28
    15fa:	81 e0       	ldi	r24, 0x01	; 1
    15fc:	0e 94 e6 0f 	call	0x1fcc	; 0x1fcc <DIO_set_port_char>
    1600:	41 e0       	ldi	r20, 0x01	; 1
    1602:	63 e0       	ldi	r22, 0x03	; 3
    1604:	82 e0       	ldi	r24, 0x02	; 2
    1606:	0e 94 6d 0f 	call	0x1eda	; 0x1eda <DIO_set_pin_value>
    160a:	83 ef       	ldi	r24, 0xF3	; 243
    160c:	91 e0       	ldi	r25, 0x01	; 1
    160e:	01 97       	sbiw	r24, 0x01	; 1
    1610:	f1 f7       	brne	.-4      	; 0x160e <LCD_Send_Data+0x2e>
    1612:	00 c0       	rjmp	.+0      	; 0x1614 <LCD_Send_Data+0x34>
    1614:	00 00       	nop
    1616:	40 e0       	ldi	r20, 0x00	; 0
    1618:	63 e0       	ldi	r22, 0x03	; 3
    161a:	82 e0       	ldi	r24, 0x02	; 2
    161c:	0e 94 6d 0f 	call	0x1eda	; 0x1eda <DIO_set_pin_value>
    1620:	cf 91       	pop	r28
    1622:	08 95       	ret

00001624 <LCD_INIT>:
    1624:	8f e0       	ldi	r24, 0x0F	; 15
    1626:	97 e2       	ldi	r25, 0x27	; 39
    1628:	01 97       	sbiw	r24, 0x01	; 1
    162a:	f1 f7       	brne	.-4      	; 0x1628 <LCD_INIT+0x4>
    162c:	00 c0       	rjmp	.+0      	; 0x162e <LCD_INIT+0xa>
    162e:	00 00       	nop
    1630:	88 e3       	ldi	r24, 0x38	; 56
    1632:	0e 94 ce 0a 	call	0x159c	; 0x159c <LCD_Send_Command>
    1636:	8c e0       	ldi	r24, 0x0C	; 12
    1638:	0e 94 ce 0a 	call	0x159c	; 0x159c <LCD_Send_Command>
    163c:	81 e0       	ldi	r24, 0x01	; 1
    163e:	0e 94 ce 0a 	call	0x159c	; 0x159c <LCD_Send_Command>
    1642:	08 95       	ret

00001644 <LCD_sendString>:
    1644:	0f 93       	push	r16
    1646:	1f 93       	push	r17
    1648:	cf 93       	push	r28
    164a:	8c 01       	movw	r16, r24
    164c:	c0 e0       	ldi	r28, 0x00	; 0
    164e:	03 c0       	rjmp	.+6      	; 0x1656 <LCD_sendString+0x12>
    1650:	0e 94 f0 0a 	call	0x15e0	; 0x15e0 <LCD_Send_Data>
    1654:	cf 5f       	subi	r28, 0xFF	; 255
    1656:	f8 01       	movw	r30, r16
    1658:	ec 0f       	add	r30, r28
    165a:	f1 1d       	adc	r31, r1
    165c:	80 81       	ld	r24, Z
    165e:	81 11       	cpse	r24, r1
    1660:	f7 cf       	rjmp	.-18     	; 0x1650 <LCD_sendString+0xc>
    1662:	cf 91       	pop	r28
    1664:	1f 91       	pop	r17
    1666:	0f 91       	pop	r16
    1668:	08 95       	ret

0000166a <LCD_ChangePOS_XY>:
    166a:	61 11       	cpse	r22, r1
    166c:	06 c0       	rjmp	.+12     	; 0x167a <LCD_ChangePOS_XY+0x10>
    166e:	98 2f       	mov	r25, r24
    1670:	20 e4       	ldi	r18, 0x40	; 64
    1672:	62 9f       	mul	r22, r18
    1674:	90 0d       	add	r25, r0
    1676:	11 24       	eor	r1, r1
    1678:	01 c0       	rjmp	.+2      	; 0x167c <LCD_ChangePOS_XY+0x12>
    167a:	90 e0       	ldi	r25, 0x00	; 0
    167c:	61 30       	cpi	r22, 0x01	; 1
    167e:	29 f4       	brne	.+10     	; 0x168a <LCD_ChangePOS_XY+0x20>
    1680:	98 2f       	mov	r25, r24
    1682:	20 e4       	ldi	r18, 0x40	; 64
    1684:	62 9f       	mul	r22, r18
    1686:	90 0d       	add	r25, r0
    1688:	11 24       	eor	r1, r1
    168a:	80 e8       	ldi	r24, 0x80	; 128
    168c:	89 0f       	add	r24, r25
    168e:	0e 94 ce 0a 	call	0x159c	; 0x159c <LCD_Send_Command>
    1692:	08 95       	ret

00001694 <LCD_INIT_DIR>:
    1694:	41 e0       	ldi	r20, 0x01	; 1
    1696:	60 e0       	ldi	r22, 0x00	; 0
    1698:	81 e0       	ldi	r24, 0x01	; 1
    169a:	0e 94 f4 0e 	call	0x1de8	; 0x1de8 <DIO_set_pin_direction>
    169e:	41 e0       	ldi	r20, 0x01	; 1
    16a0:	61 e0       	ldi	r22, 0x01	; 1
    16a2:	81 e0       	ldi	r24, 0x01	; 1
    16a4:	0e 94 f4 0e 	call	0x1de8	; 0x1de8 <DIO_set_pin_direction>
    16a8:	41 e0       	ldi	r20, 0x01	; 1
    16aa:	62 e0       	ldi	r22, 0x02	; 2
    16ac:	81 e0       	ldi	r24, 0x01	; 1
    16ae:	0e 94 f4 0e 	call	0x1de8	; 0x1de8 <DIO_set_pin_direction>
    16b2:	41 e0       	ldi	r20, 0x01	; 1
    16b4:	63 e0       	ldi	r22, 0x03	; 3
    16b6:	81 e0       	ldi	r24, 0x01	; 1
    16b8:	0e 94 f4 0e 	call	0x1de8	; 0x1de8 <DIO_set_pin_direction>
    16bc:	41 e0       	ldi	r20, 0x01	; 1
    16be:	64 e0       	ldi	r22, 0x04	; 4
    16c0:	81 e0       	ldi	r24, 0x01	; 1
    16c2:	0e 94 f4 0e 	call	0x1de8	; 0x1de8 <DIO_set_pin_direction>
    16c6:	41 e0       	ldi	r20, 0x01	; 1
    16c8:	65 e0       	ldi	r22, 0x05	; 5
    16ca:	81 e0       	ldi	r24, 0x01	; 1
    16cc:	0e 94 f4 0e 	call	0x1de8	; 0x1de8 <DIO_set_pin_direction>
    16d0:	41 e0       	ldi	r20, 0x01	; 1
    16d2:	66 e0       	ldi	r22, 0x06	; 6
    16d4:	81 e0       	ldi	r24, 0x01	; 1
    16d6:	0e 94 f4 0e 	call	0x1de8	; 0x1de8 <DIO_set_pin_direction>
    16da:	41 e0       	ldi	r20, 0x01	; 1
    16dc:	67 e0       	ldi	r22, 0x07	; 7
    16de:	81 e0       	ldi	r24, 0x01	; 1
    16e0:	0e 94 f4 0e 	call	0x1de8	; 0x1de8 <DIO_set_pin_direction>
    16e4:	41 e0       	ldi	r20, 0x01	; 1
    16e6:	63 e0       	ldi	r22, 0x03	; 3
    16e8:	82 e0       	ldi	r24, 0x02	; 2
    16ea:	0e 94 f4 0e 	call	0x1de8	; 0x1de8 <DIO_set_pin_direction>
    16ee:	41 e0       	ldi	r20, 0x01	; 1
    16f0:	64 e0       	ldi	r22, 0x04	; 4
    16f2:	82 e0       	ldi	r24, 0x02	; 2
    16f4:	0e 94 f4 0e 	call	0x1de8	; 0x1de8 <DIO_set_pin_direction>
    16f8:	41 e0       	ldi	r20, 0x01	; 1
    16fa:	65 e0       	ldi	r22, 0x05	; 5
    16fc:	82 e0       	ldi	r24, 0x02	; 2
    16fe:	0e 94 f4 0e 	call	0x1de8	; 0x1de8 <DIO_set_pin_direction>
    1702:	08 95       	ret

00001704 <LCD_Clear>:
    1704:	81 e0       	ldi	r24, 0x01	; 1
    1706:	0e 94 ce 0a 	call	0x159c	; 0x159c <LCD_Send_Command>
    170a:	08 95       	ret

0000170c <LCD_voidWriteNumber>:
	return Local_u16Result;
}


void LCD_voidWriteNumber(uint16 Copy_u16Number)
{
    170c:	ef 92       	push	r14
    170e:	ff 92       	push	r15
    1710:	0f 93       	push	r16
    1712:	1f 93       	push	r17
    1714:	cf 93       	push	r28
    1716:	df 93       	push	r29
    1718:	ec 01       	movw	r28, r24
	uint8 Local_u8Counter = 0, Local_u8Digits = 0, Local_u8Current;
	uint16 Local_u16CopyNumber = Copy_u16Number;

	if(0 == Copy_u16Number)
    171a:	00 97       	sbiw	r24, 0x00	; 0
    171c:	89 f4       	brne	.+34     	; 0x1740 <LCD_voidWriteNumber+0x34>
	{
		LCD_Send_Data('0');
    171e:	80 e3       	ldi	r24, 0x30	; 48
    1720:	0e 94 f0 0a 	call	0x15e0	; 0x15e0 <LCD_Send_Data>
    1724:	29 c0       	rjmp	.+82     	; 0x1778 <LCD_voidWriteNumber+0x6c>
	}
	else
	{
		while(Local_u16CopyNumber)
		{
			Local_u16CopyNumber /= 10;
    1726:	ad ec       	ldi	r26, 0xCD	; 205
    1728:	bc ec       	ldi	r27, 0xCC	; 204
    172a:	0e 94 57 10 	call	0x20ae	; 0x20ae <__umulhisi3>
    172e:	9c 01       	movw	r18, r24
    1730:	36 95       	lsr	r19
    1732:	27 95       	ror	r18
    1734:	36 95       	lsr	r19
    1736:	27 95       	ror	r18
    1738:	36 95       	lsr	r19
    173a:	27 95       	ror	r18
			Local_u8Digits++;
    173c:	0f 5f       	subi	r16, 0xFF	; 255
    173e:	02 c0       	rjmp	.+4      	; 0x1744 <LCD_voidWriteNumber+0x38>
    1740:	9c 01       	movw	r18, r24
    1742:	00 e0       	ldi	r16, 0x00	; 0
	{
		LCD_Send_Data('0');
	}
	else
	{
		while(Local_u16CopyNumber)
    1744:	21 15       	cp	r18, r1
    1746:	31 05       	cpc	r19, r1
    1748:	71 f7       	brne	.-36     	; 0x1726 <LCD_voidWriteNumber+0x1a>
    174a:	10 e0       	ldi	r17, 0x00	; 0
    174c:	13 c0       	rjmp	.+38     	; 0x1774 <LCD_voidWriteNumber+0x68>
		}
		Local_u16CopyNumber = Copy_u16Number;

		for(Local_u8Counter = 0; Local_u8Counter < Local_u8Digits; Local_u8Counter++)
		{
			Local_u8Current = Local_u16CopyNumber / (Private_u16GetPower(10, Local_u8Digits - 1 - Local_u8Counter));
    174e:	60 2f       	mov	r22, r16
    1750:	61 1b       	sub	r22, r17
    1752:	61 50       	subi	r22, 0x01	; 1
    1754:	8a e0       	ldi	r24, 0x0A	; 10
    1756:	0e 94 bf 0a 	call	0x157e	; 0x157e <Private_u16GetPower>
    175a:	bc 01       	movw	r22, r24
    175c:	ce 01       	movw	r24, r28
    175e:	0e 94 21 10 	call	0x2042	; 0x2042 <__udivmodhi4>
    1762:	e8 2e       	mov	r14, r24
    1764:	f9 2e       	mov	r15, r25
			LCD_Send_Data(Local_u8Current + '0');
    1766:	80 e3       	ldi	r24, 0x30	; 48
    1768:	86 0f       	add	r24, r22
    176a:	0e 94 f0 0a 	call	0x15e0	; 0x15e0 <LCD_Send_Data>
			Local_u16CopyNumber %= (Private_u16GetPower(10, Local_u8Digits - 1 - Local_u8Counter));
    176e:	ce 2d       	mov	r28, r14
    1770:	df 2d       	mov	r29, r15
			Local_u16CopyNumber /= 10;
			Local_u8Digits++;
		}
		Local_u16CopyNumber = Copy_u16Number;

		for(Local_u8Counter = 0; Local_u8Counter < Local_u8Digits; Local_u8Counter++)
    1772:	1f 5f       	subi	r17, 0xFF	; 255
    1774:	10 17       	cp	r17, r16
    1776:	58 f3       	brcs	.-42     	; 0x174e <LCD_voidWriteNumber+0x42>
			Local_u8Current = Local_u16CopyNumber / (Private_u16GetPower(10, Local_u8Digits - 1 - Local_u8Counter));
			LCD_Send_Data(Local_u8Current + '0');
			Local_u16CopyNumber %= (Private_u16GetPower(10, Local_u8Digits - 1 - Local_u8Counter));
		}
	}
}
    1778:	df 91       	pop	r29
    177a:	cf 91       	pop	r28
    177c:	1f 91       	pop	r17
    177e:	0f 91       	pop	r16
    1780:	ff 90       	pop	r15
    1782:	ef 90       	pop	r14
    1784:	08 95       	ret

00001786 <ADC_Task>:
	uint8 local_state; // check the function return true if work correct false if not

	while(1)
	{
		// this function use to swap between the sensor in adc multiplexer 
		local_state=ADC_Start_Chain_Conversion_ASYN(&ADC_chain);
    1786:	89 e6       	ldi	r24, 0x69	; 105
    1788:	97 e0       	ldi	r25, 0x07	; 7
    178a:	0e 94 35 0e 	call	0x1c6a	; 0x1c6a <ADC_Start_Chain_Conversion_ASYN>
		if(xSemaphoreTake(bsADC, portMAX_DELAY) == pdPASS)
    178e:	6f ef       	ldi	r22, 0xFF	; 255
    1790:	7f ef       	ldi	r23, 0xFF	; 255
    1792:	80 91 53 07 	lds	r24, 0x0753	; 0x800753 <bsADC>
    1796:	90 91 54 07 	lds	r25, 0x0754	; 0x800754 <bsADC+0x1>
    179a:	0e 94 39 04 	call	0x872	; 0x872 <xQueueSemaphoreTake>
    179e:	81 30       	cpi	r24, 0x01	; 1
    17a0:	41 f0       	breq	.+16     	; 0x17b2 <ADC_Task+0x2c>
			//UART_voidSendStringBlocking("im adc\r\n");
	
		}
		else
		{
			LCD_ChangePOS_XY(4, 1);
    17a2:	61 e0       	ldi	r22, 0x01	; 1
    17a4:	84 e0       	ldi	r24, 0x04	; 4
    17a6:	0e 94 35 0b 	call	0x166a	; 0x166a <LCD_ChangePOS_XY>
			LCD_sendString("TimeOut");
    17aa:	8d e7       	ldi	r24, 0x7D	; 125
    17ac:	90 e0       	ldi	r25, 0x00	; 0
    17ae:	0e 94 22 0b 	call	0x1644	; 0x1644 <LCD_sendString>
		}
		vTaskDelay(100);
    17b2:	84 e6       	ldi	r24, 0x64	; 100
    17b4:	90 e0       	ldi	r25, 0x00	; 0
    17b6:	0e 94 4d 08 	call	0x109a	; 0x109a <vTaskDelay>
	}
    17ba:	e5 cf       	rjmp	.-54     	; 0x1786 <ADC_Task>

000017bc <POT_Task>:
{
	while(1)
	{
		
		// analog equation calculation
		Analog1 = ((uint32)ADC_chain.ChainResult[0]*5000)/ 1023 ;
    17bc:	e0 91 6b 07 	lds	r30, 0x076B	; 0x80076b <ADC_chain+0x2>
    17c0:	f0 91 6c 07 	lds	r31, 0x076C	; 0x80076c <ADC_chain+0x3>
    17c4:	20 81       	ld	r18, Z
    17c6:	31 81       	ldd	r19, Z+1	; 0x01
    17c8:	a8 e8       	ldi	r26, 0x88	; 136
    17ca:	b3 e1       	ldi	r27, 0x13	; 19
    17cc:	0e 94 57 10 	call	0x20ae	; 0x20ae <__umulhisi3>
    17d0:	2f ef       	ldi	r18, 0xFF	; 255
    17d2:	33 e0       	ldi	r19, 0x03	; 3
    17d4:	40 e0       	ldi	r20, 0x00	; 0
    17d6:	50 e0       	ldi	r21, 0x00	; 0
    17d8:	0e 94 35 10 	call	0x206a	; 0x206a <__udivmodsi4>
    17dc:	30 93 5d 07 	sts	0x075D, r19	; 0x80075d <Analog1+0x1>
    17e0:	20 93 5c 07 	sts	0x075C, r18	; 0x80075c <Analog1>
		/* if the flag true (i.e the system open (true password) ) the gas sensor start detect*/
		if(flag==1)
    17e4:	80 91 56 07 	lds	r24, 0x0756	; 0x800756 <flag>
    17e8:	81 30       	cpi	r24, 0x01	; 1
    17ea:	71 f4       	brne	.+28     	; 0x1808 <POT_Task+0x4c>
		{
			if(Analog1>2500)
    17ec:	25 3c       	cpi	r18, 0xC5	; 197
    17ee:	39 40       	sbci	r19, 0x09	; 9
    17f0:	30 f0       	brcs	.+12     	; 0x17fe <POT_Task+0x42>
			{
				DIO_set_pin_value(PORTC_RTOS,pin1,HIGH); // buz and door on
    17f2:	41 e0       	ldi	r20, 0x01	; 1
    17f4:	61 e0       	ldi	r22, 0x01	; 1
    17f6:	82 e0       	ldi	r24, 0x02	; 2
    17f8:	0e 94 6d 0f 	call	0x1eda	; 0x1eda <DIO_set_pin_value>
    17fc:	05 c0       	rjmp	.+10     	; 0x1808 <POT_Task+0x4c>
			}
			else
			{
				DIO_set_pin_value(PORTC_RTOS,pin1,LOW); // buz and door off
    17fe:	40 e0       	ldi	r20, 0x00	; 0
    1800:	61 e0       	ldi	r22, 0x01	; 1
    1802:	82 e0       	ldi	r24, 0x02	; 2
    1804:	0e 94 6d 0f 	call	0x1eda	; 0x1eda <DIO_set_pin_value>
		{
			// do nothing
		}
		
		
		vTaskDelay(100);
    1808:	84 e6       	ldi	r24, 0x64	; 100
    180a:	90 e0       	ldi	r25, 0x00	; 0
    180c:	0e 94 4d 08 	call	0x109a	; 0x109a <vTaskDelay>
	}
    1810:	d5 cf       	rjmp	.-86     	; 0x17bc <POT_Task>

00001812 <LM35_Task>:
{
	
	while(1)
	{
		//UART_voidSendStringBlocking("im temp\r\n");
		Analog2 = ((uint32)ADC_chain.ChainResult[1]*5000)/ 1023 ;
    1812:	e0 91 6b 07 	lds	r30, 0x076B	; 0x80076b <ADC_chain+0x2>
    1816:	f0 91 6c 07 	lds	r31, 0x076C	; 0x80076c <ADC_chain+0x3>
    181a:	22 81       	ldd	r18, Z+2	; 0x02
    181c:	33 81       	ldd	r19, Z+3	; 0x03
    181e:	a8 e8       	ldi	r26, 0x88	; 136
    1820:	b3 e1       	ldi	r27, 0x13	; 19
    1822:	0e 94 57 10 	call	0x20ae	; 0x20ae <__umulhisi3>
    1826:	2f ef       	ldi	r18, 0xFF	; 255
    1828:	33 e0       	ldi	r19, 0x03	; 3
    182a:	40 e0       	ldi	r20, 0x00	; 0
    182c:	50 e0       	ldi	r21, 0x00	; 0
    182e:	0e 94 35 10 	call	0x206a	; 0x206a <__udivmodsi4>
		temp = Analog2/10;
    1832:	ad ec       	ldi	r26, 0xCD	; 205
    1834:	bc ec       	ldi	r27, 0xCC	; 204
    1836:	0e 94 57 10 	call	0x20ae	; 0x20ae <__umulhisi3>
    183a:	96 95       	lsr	r25
    183c:	87 95       	ror	r24
    183e:	96 95       	lsr	r25
    1840:	87 95       	ror	r24
    1842:	96 95       	lsr	r25
    1844:	87 95       	ror	r24
    1846:	90 93 5b 07 	sts	0x075B, r25	; 0x80075b <temp+0x1>
    184a:	80 93 5a 07 	sts	0x075A, r24	; 0x80075a <temp>
		if(flag==1)
    184e:	20 91 56 07 	lds	r18, 0x0756	; 0x800756 <flag>
    1852:	21 30       	cpi	r18, 0x01	; 1
    1854:	69 f4       	brne	.+26     	; 0x1870 <LM35_Task+0x5e>
		{
			if (temp>20) // open the fan
    1856:	45 97       	sbiw	r24, 0x15	; 21
    1858:	30 f0       	brcs	.+12     	; 0x1866 <LM35_Task+0x54>
			{
				DIO_set_pin_value(PORTC_RTOS,pin0,HIGH);
    185a:	41 e0       	ldi	r20, 0x01	; 1
    185c:	60 e0       	ldi	r22, 0x00	; 0
    185e:	82 e0       	ldi	r24, 0x02	; 2
    1860:	0e 94 6d 0f 	call	0x1eda	; 0x1eda <DIO_set_pin_value>
    1864:	05 c0       	rjmp	.+10     	; 0x1870 <LM35_Task+0x5e>
			}
			else // close the fan
			{
				DIO_set_pin_value(PORTC_RTOS,pin0,LOW); 
    1866:	40 e0       	ldi	r20, 0x00	; 0
    1868:	60 e0       	ldi	r22, 0x00	; 0
    186a:	82 e0       	ldi	r24, 0x02	; 2
    186c:	0e 94 6d 0f 	call	0x1eda	; 0x1eda <DIO_set_pin_value>
		}
		else
		{
			// do nothing
		}
		vTaskDelay(100);
    1870:	84 e6       	ldi	r24, 0x64	; 100
    1872:	90 e0       	ldi	r25, 0x00	; 0
    1874:	0e 94 4d 08 	call	0x109a	; 0x109a <vTaskDelay>
	}
    1878:	cc cf       	rjmp	.-104    	; 0x1812 <LM35_Task>

0000187a <ISR_Notification>:
}

// this function used for ADC notification when end conversion the adc give the semaphore
void ISR_Notification(void)
{
	xSemaphoreGive(bsADC);
    187a:	20 e0       	ldi	r18, 0x00	; 0
    187c:	40 e0       	ldi	r20, 0x00	; 0
    187e:	50 e0       	ldi	r21, 0x00	; 0
    1880:	60 e0       	ldi	r22, 0x00	; 0
    1882:	70 e0       	ldi	r23, 0x00	; 0
    1884:	80 91 53 07 	lds	r24, 0x0753	; 0x800753 <bsADC>
    1888:	90 91 54 07 	lds	r25, 0x0754	; 0x800754 <bsADC+0x1>
    188c:	0e 94 a7 03 	call	0x74e	; 0x74e <xQueueGenericSend>
    1890:	08 95       	ret

00001892 <ActionTask>:
void ActionTask(void *pv)
{
	uint8 static welcome=1,swap=0;
	while(1)
	{
			if(flag==0)//  if the password wrong or in the init 
    1892:	80 91 56 07 	lds	r24, 0x0756	; 0x800756 <flag>
    1896:	81 11       	cpse	r24, r1
    1898:	14 c0       	rjmp	.+40     	; 0x18c2 <ActionTask+0x30>
			{				
							xSemaphoreGive(lcd);
    189a:	20 e0       	ldi	r18, 0x00	; 0
    189c:	40 e0       	ldi	r20, 0x00	; 0
    189e:	50 e0       	ldi	r21, 0x00	; 0
    18a0:	60 e0       	ldi	r22, 0x00	; 0
    18a2:	70 e0       	ldi	r23, 0x00	; 0
    18a4:	80 91 51 07 	lds	r24, 0x0751	; 0x800751 <lcd>
    18a8:	90 91 52 07 	lds	r25, 0x0752	; 0x800752 <lcd+0x1>
    18ac:	0e 94 a7 03 	call	0x74e	; 0x74e <xQueueGenericSend>
					LCD_ChangePOS_XY(0, 0);
    18b0:	60 e0       	ldi	r22, 0x00	; 0
    18b2:	80 e0       	ldi	r24, 0x00	; 0
    18b4:	0e 94 35 0b 	call	0x166a	; 0x166a <LCD_ChangePOS_XY>
								//LCD_voidWriteNumber(local_counter);
					LCD_sendString("enter password");
    18b8:	85 e8       	ldi	r24, 0x85	; 133
    18ba:	90 e0       	ldi	r25, 0x00	; 0
    18bc:	0e 94 22 0b 	call	0x1644	; 0x1644 <LCD_sendString>
    18c0:	bd c0       	rjmp	.+378    	; 0x1a3c <ActionTask+0x1aa>
	
			}

			 else if (flag ==1) // if pass is right
    18c2:	81 30       	cpi	r24, 0x01	; 1
    18c4:	09 f0       	breq	.+2      	; 0x18c8 <ActionTask+0x36>
    18c6:	ba c0       	rjmp	.+372    	; 0x1a3c <ActionTask+0x1aa>
			{
				
				if(welcome==1) // i need this fun run on time only if the pass correct
    18c8:	80 91 74 00 	lds	r24, 0x0074	; 0x800074 <welcome.2357>
    18cc:	81 30       	cpi	r24, 0x01	; 1
    18ce:	b9 f4       	brne	.+46     	; 0x18fe <ActionTask+0x6c>
				{
					xSemaphoreGive(lcd);
    18d0:	20 e0       	ldi	r18, 0x00	; 0
    18d2:	40 e0       	ldi	r20, 0x00	; 0
    18d4:	50 e0       	ldi	r21, 0x00	; 0
    18d6:	60 e0       	ldi	r22, 0x00	; 0
    18d8:	70 e0       	ldi	r23, 0x00	; 0
    18da:	80 91 51 07 	lds	r24, 0x0751	; 0x800751 <lcd>
    18de:	90 91 52 07 	lds	r25, 0x0752	; 0x800752 <lcd+0x1>
    18e2:	0e 94 a7 03 	call	0x74e	; 0x74e <xQueueGenericSend>
					LCD_Clear();
    18e6:	0e 94 82 0b 	call	0x1704	; 0x1704 <LCD_Clear>
					LCD_sendString("correct password");
    18ea:	84 e9       	ldi	r24, 0x94	; 148
    18ec:	90 e0       	ldi	r25, 0x00	; 0
    18ee:	0e 94 22 0b 	call	0x1644	; 0x1644 <LCD_sendString>
				
					welcome=0; //change it to zero 
    18f2:	10 92 74 00 	sts	0x0074, r1	; 0x800074 <welcome.2357>
					vTaskDelay(1000); // wait for 1000 sec 
    18f6:	88 ee       	ldi	r24, 0xE8	; 232
    18f8:	93 e0       	ldi	r25, 0x03	; 3
    18fa:	0e 94 4d 08 	call	0x109a	; 0x109a <vTaskDelay>
				}
				
				if(swap==0) // swap use for swapping between 2 line in lcd( first for temp , pot ) and ( second for the door and fan)
    18fe:	80 91 50 07 	lds	r24, 0x0750	; 0x800750 <swap.2358>
    1902:	81 11       	cpse	r24, r1
    1904:	55 c0       	rjmp	.+170    	; 0x19b0 <ActionTask+0x11e>
				{
					xSemaphoreGive(lcd);
    1906:	20 e0       	ldi	r18, 0x00	; 0
    1908:	40 e0       	ldi	r20, 0x00	; 0
    190a:	50 e0       	ldi	r21, 0x00	; 0
    190c:	60 e0       	ldi	r22, 0x00	; 0
    190e:	70 e0       	ldi	r23, 0x00	; 0
    1910:	80 91 51 07 	lds	r24, 0x0751	; 0x800751 <lcd>
    1914:	90 91 52 07 	lds	r25, 0x0752	; 0x800752 <lcd+0x1>
    1918:	0e 94 a7 03 	call	0x74e	; 0x74e <xQueueGenericSend>
					LCD_Clear();
    191c:	0e 94 82 0b 	call	0x1704	; 0x1704 <LCD_Clear>
					// this for gas sensor
					LCD_ChangePOS_XY(0, 0);
    1920:	60 e0       	ldi	r22, 0x00	; 0
    1922:	80 e0       	ldi	r24, 0x00	; 0
    1924:	0e 94 35 0b 	call	0x166a	; 0x166a <LCD_ChangePOS_XY>
					LCD_sendString(" POT=");
    1928:	85 ea       	ldi	r24, 0xA5	; 165
    192a:	90 e0       	ldi	r25, 0x00	; 0
    192c:	0e 94 22 0b 	call	0x1644	; 0x1644 <LCD_sendString>

					LCD_ChangePOS_XY(10, 0);
    1930:	60 e0       	ldi	r22, 0x00	; 0
    1932:	8a e0       	ldi	r24, 0x0A	; 10
    1934:	0e 94 35 0b 	call	0x166a	; 0x166a <LCD_ChangePOS_XY>
					LCD_sendString("mv");
    1938:	8b ea       	ldi	r24, 0xAB	; 171
    193a:	90 e0       	ldi	r25, 0x00	; 0
    193c:	0e 94 22 0b 	call	0x1644	; 0x1644 <LCD_sendString>

					//	this for temp sensor
					LCD_ChangePOS_XY(0, 1);
    1940:	61 e0       	ldi	r22, 0x01	; 1
    1942:	80 e0       	ldi	r24, 0x00	; 0
    1944:	0e 94 35 0b 	call	0x166a	; 0x166a <LCD_ChangePOS_XY>
					LCD_sendString(" temp=");
    1948:	8e ea       	ldi	r24, 0xAE	; 174
    194a:	90 e0       	ldi	r25, 0x00	; 0
    194c:	0e 94 22 0b 	call	0x1644	; 0x1644 <LCD_sendString>

					LCD_ChangePOS_XY(11, 1);
    1950:	61 e0       	ldi	r22, 0x01	; 1
    1952:	8b e0       	ldi	r24, 0x0B	; 11
    1954:	0e 94 35 0b 	call	0x166a	; 0x166a <LCD_ChangePOS_XY>
					LCD_sendString("c");
    1958:	85 eb       	ldi	r24, 0xB5	; 181
    195a:	90 e0       	ldi	r25, 0x00	; 0
    195c:	0e 94 22 0b 	call	0x1644	; 0x1644 <LCD_sendString>
					
					// this for gas sensor value
					LCD_ChangePOS_XY(5, 0);
    1960:	60 e0       	ldi	r22, 0x00	; 0
    1962:	85 e0       	ldi	r24, 0x05	; 5
    1964:	0e 94 35 0b 	call	0x166a	; 0x166a <LCD_ChangePOS_XY>
					LCD_sendString("    ");
    1968:	87 eb       	ldi	r24, 0xB7	; 183
    196a:	90 e0       	ldi	r25, 0x00	; 0
    196c:	0e 94 22 0b 	call	0x1644	; 0x1644 <LCD_sendString>
					LCD_ChangePOS_XY(5, 0);
    1970:	60 e0       	ldi	r22, 0x00	; 0
    1972:	85 e0       	ldi	r24, 0x05	; 5
    1974:	0e 94 35 0b 	call	0x166a	; 0x166a <LCD_ChangePOS_XY>
					LCD_voidWriteNumber(Analog1);
    1978:	80 91 5c 07 	lds	r24, 0x075C	; 0x80075c <Analog1>
    197c:	90 91 5d 07 	lds	r25, 0x075D	; 0x80075d <Analog1+0x1>
    1980:	0e 94 86 0b 	call	0x170c	; 0x170c <LCD_voidWriteNumber>
					
					// this for temp sensor value
					LCD_ChangePOS_XY(6, 1);
    1984:	61 e0       	ldi	r22, 0x01	; 1
    1986:	86 e0       	ldi	r24, 0x06	; 6
    1988:	0e 94 35 0b 	call	0x166a	; 0x166a <LCD_ChangePOS_XY>
					LCD_sendString("    ");
    198c:	87 eb       	ldi	r24, 0xB7	; 183
    198e:	90 e0       	ldi	r25, 0x00	; 0
    1990:	0e 94 22 0b 	call	0x1644	; 0x1644 <LCD_sendString>
					LCD_ChangePOS_XY(6, 1);
    1994:	61 e0       	ldi	r22, 0x01	; 1
    1996:	86 e0       	ldi	r24, 0x06	; 6
    1998:	0e 94 35 0b 	call	0x166a	; 0x166a <LCD_ChangePOS_XY>
					LCD_voidWriteNumber(temp);
    199c:	80 91 5a 07 	lds	r24, 0x075A	; 0x80075a <temp>
    19a0:	90 91 5b 07 	lds	r25, 0x075B	; 0x80075b <temp+0x1>
    19a4:	0e 94 86 0b 	call	0x170c	; 0x170c <LCD_voidWriteNumber>
				
					swap=1;
    19a8:	81 e0       	ldi	r24, 0x01	; 1
    19aa:	80 93 50 07 	sts	0x0750, r24	; 0x800750 <swap.2358>
    19ae:	46 c0       	rjmp	.+140    	; 0x1a3c <ActionTask+0x1aa>
				}
				else if (swap==1)
    19b0:	81 30       	cpi	r24, 0x01	; 1
    19b2:	09 f0       	breq	.+2      	; 0x19b6 <ActionTask+0x124>
    19b4:	43 c0       	rjmp	.+134    	; 0x1a3c <ActionTask+0x1aa>
				{
					LCD_Clear();
    19b6:	0e 94 82 0b 	call	0x1704	; 0x1704 <LCD_Clear>
					// door and buzzer for gas sensor
					LCD_ChangePOS_XY(0, 0);
    19ba:	60 e0       	ldi	r22, 0x00	; 0
    19bc:	80 e0       	ldi	r24, 0x00	; 0
    19be:	0e 94 35 0b 	call	0x166a	; 0x166a <LCD_ChangePOS_XY>
					LCD_sendString(" door=");
    19c2:	8c eb       	ldi	r24, 0xBC	; 188
    19c4:	90 e0       	ldi	r25, 0x00	; 0
    19c6:	0e 94 22 0b 	call	0x1644	; 0x1644 <LCD_sendString>
					
					if(Analog1>2500) // if the value greater than 2500 the door open
    19ca:	80 91 5c 07 	lds	r24, 0x075C	; 0x80075c <Analog1>
    19ce:	90 91 5d 07 	lds	r25, 0x075D	; 0x80075d <Analog1+0x1>
    19d2:	85 3c       	cpi	r24, 0xC5	; 197
    19d4:	99 40       	sbci	r25, 0x09	; 9
    19d6:	48 f0       	brcs	.+18     	; 0x19ea <ActionTask+0x158>
					{
						LCD_ChangePOS_XY(7, 0);
    19d8:	60 e0       	ldi	r22, 0x00	; 0
    19da:	87 e0       	ldi	r24, 0x07	; 7
    19dc:	0e 94 35 0b 	call	0x166a	; 0x166a <LCD_ChangePOS_XY>
						LCD_sendString("open");
    19e0:	83 ec       	ldi	r24, 0xC3	; 195
    19e2:	90 e0       	ldi	r25, 0x00	; 0
    19e4:	0e 94 22 0b 	call	0x1644	; 0x1644 <LCD_sendString>
    19e8:	08 c0       	rjmp	.+16     	; 0x19fa <ActionTask+0x168>
					}
					else // the door closed
					{
						LCD_ChangePOS_XY(7, 0);
    19ea:	60 e0       	ldi	r22, 0x00	; 0
    19ec:	87 e0       	ldi	r24, 0x07	; 7
    19ee:	0e 94 35 0b 	call	0x166a	; 0x166a <LCD_ChangePOS_XY>
						LCD_sendString("close");
    19f2:	88 ec       	ldi	r24, 0xC8	; 200
    19f4:	90 e0       	ldi	r25, 0x00	; 0
    19f6:	0e 94 22 0b 	call	0x1644	; 0x1644 <LCD_sendString>
					}
					

					//temp
					LCD_ChangePOS_XY(0, 1);
    19fa:	61 e0       	ldi	r22, 0x01	; 1
    19fc:	80 e0       	ldi	r24, 0x00	; 0
    19fe:	0e 94 35 0b 	call	0x166a	; 0x166a <LCD_ChangePOS_XY>
					LCD_sendString(" fan=");
    1a02:	8e ec       	ldi	r24, 0xCE	; 206
    1a04:	90 e0       	ldi	r25, 0x00	; 0
    1a06:	0e 94 22 0b 	call	0x1644	; 0x1644 <LCD_sendString>
					// if temp > 20 the fan open 
					if(temp>20)
    1a0a:	80 91 5a 07 	lds	r24, 0x075A	; 0x80075a <temp>
    1a0e:	90 91 5b 07 	lds	r25, 0x075B	; 0x80075b <temp+0x1>
    1a12:	45 97       	sbiw	r24, 0x15	; 21
    1a14:	48 f0       	brcs	.+18     	; 0x1a28 <ActionTask+0x196>
					{
						LCD_ChangePOS_XY(5, 1);
    1a16:	61 e0       	ldi	r22, 0x01	; 1
    1a18:	85 e0       	ldi	r24, 0x05	; 5
    1a1a:	0e 94 35 0b 	call	0x166a	; 0x166a <LCD_ChangePOS_XY>
						LCD_sendString("open");
    1a1e:	83 ec       	ldi	r24, 0xC3	; 195
    1a20:	90 e0       	ldi	r25, 0x00	; 0
    1a22:	0e 94 22 0b 	call	0x1644	; 0x1644 <LCD_sendString>
    1a26:	08 c0       	rjmp	.+16     	; 0x1a38 <ActionTask+0x1a6>
					}
					else // the fan closed
					{
						LCD_ChangePOS_XY(5, 1);
    1a28:	61 e0       	ldi	r22, 0x01	; 1
    1a2a:	85 e0       	ldi	r24, 0x05	; 5
    1a2c:	0e 94 35 0b 	call	0x166a	; 0x166a <LCD_ChangePOS_XY>
						LCD_sendString("close");
    1a30:	88 ec       	ldi	r24, 0xC8	; 200
    1a32:	90 e0       	ldi	r25, 0x00	; 0
    1a34:	0e 94 22 0b 	call	0x1644	; 0x1644 <LCD_sendString>
					}
					
				//	_delay_ms(2000);
					swap=0;
    1a38:	10 92 50 07 	sts	0x0750, r1	; 0x800750 <swap.2358>
				

			}
		
		
		vTaskDelay(1000);
    1a3c:	88 ee       	ldi	r24, 0xE8	; 232
    1a3e:	93 e0       	ldi	r25, 0x03	; 3
    1a40:	0e 94 4d 08 	call	0x109a	; 0x109a <vTaskDelay>
	}
    1a44:	26 cf       	rjmp	.-436    	; 0x1892 <ActionTask>

00001a46 <SystemInit>:

// this fun for system init
void SystemInit(void)
{
	/*LCD Init*/
	LCD_INIT_DIR();
    1a46:	0e 94 4a 0b 	call	0x1694	; 0x1694 <LCD_INIT_DIR>
	LCD_INIT();
    1a4a:	0e 94 12 0b 	call	0x1624	; 0x1624 <LCD_INIT>
	
	/* keypad init*/
	keypad_init();
    1a4e:	0e 94 70 0a 	call	0x14e0	; 0x14e0 <keypad_init>
	
	DIO_set_pin_direction(PORTC_RTOS,pin0,output) ;	// fan
    1a52:	41 e0       	ldi	r20, 0x01	; 1
    1a54:	60 e0       	ldi	r22, 0x00	; 0
    1a56:	82 e0       	ldi	r24, 0x02	; 2
    1a58:	0e 94 f4 0e 	call	0x1de8	; 0x1de8 <DIO_set_pin_direction>
	DIO_set_pin_direction(PORTC_RTOS,pin1,output) ;	// window
    1a5c:	41 e0       	ldi	r20, 0x01	; 1
    1a5e:	61 e0       	ldi	r22, 0x01	; 1
    1a60:	82 e0       	ldi	r24, 0x02	; 2
    1a62:	0e 94 f4 0e 	call	0x1de8	; 0x1de8 <DIO_set_pin_direction>
	
	/*ADC Init*/
	ADC_init();
    1a66:	0e 94 25 0e 	call	0x1c4a	; 0x1c4a <ADC_init>
	
	/* open global init*/
	asm("SEI");
    1a6a:	78 94       	sei
    1a6c:	08 95       	ret

00001a6e <main>:
xSemaphoreHandle   lcd = NULL;
// this var for adc chain
Chain_t ADC_chain;

int main(void)
{
    1a6e:	cf 93       	push	r28
    1a70:	df 93       	push	r29
    1a72:	cd b7       	in	r28, 0x3d	; 61
    1a74:	de b7       	in	r29, 0x3e	; 62
    1a76:	29 97       	sbiw	r28, 0x09	; 9
    1a78:	0f b6       	in	r0, 0x3f	; 63
    1a7a:	f8 94       	cli
    1a7c:	de bf       	out	0x3e, r29	; 62
    1a7e:	0f be       	out	0x3f, r0	; 63
    1a80:	cd bf       	out	0x3d, r28	; 61
	//arr for channels used (channel 6 not used now)
	uint8 channel_arr[3]={0,7,6};
    1a82:	19 82       	std	Y+1, r1	; 0x01
    1a84:	87 e0       	ldi	r24, 0x07	; 7
    1a86:	8a 83       	std	Y+2, r24	; 0x02
    1a88:	86 e0       	ldi	r24, 0x06	; 6
    1a8a:	8b 83       	std	Y+3, r24	; 0x03
	// arr for  channels result	
	uint16 channel_result[3]={0};
    1a8c:	de 01       	movw	r26, r28
    1a8e:	14 96       	adiw	r26, 0x04	; 4
    1a90:	fd 01       	movw	r30, r26
    1a92:	11 92       	st	Z+, r1
    1a94:	8a 95       	dec	r24
    1a96:	e9 f7       	brne	.-6      	; 0x1a92 <main+0x24>
	//  no of channel used	
	uint8 channel_size=3;
	
	// pass the var to struct (ADC_chain)
	ADC_chain.ChainChannel=channel_arr;
    1a98:	e9 e6       	ldi	r30, 0x69	; 105
    1a9a:	f7 e0       	ldi	r31, 0x07	; 7
    1a9c:	ce 01       	movw	r24, r28
    1a9e:	01 96       	adiw	r24, 0x01	; 1
    1aa0:	91 83       	std	Z+1, r25	; 0x01
    1aa2:	80 83       	st	Z, r24
	ADC_chain.ChainResult=channel_result;
    1aa4:	b3 83       	std	Z+3, r27	; 0x03
    1aa6:	a2 83       	std	Z+2, r26	; 0x02
	ADC_chain.ChainSize=channel_size;
    1aa8:	83 e0       	ldi	r24, 0x03	; 3
    1aaa:	84 83       	std	Z+4, r24	; 0x04
	ADC_chain.ChainNotificationFunc=&ISR_Notification;
    1aac:	8d e3       	ldi	r24, 0x3D	; 61
    1aae:	9c e0       	ldi	r25, 0x0C	; 12
    1ab0:	96 83       	std	Z+6, r25	; 0x06
    1ab2:	85 83       	std	Z+5, r24	; 0x05
	// system init
	SystemInit();
    1ab4:	0e 94 23 0d 	call	0x1a46	; 0x1a46 <SystemInit>
	
	/* task creater*/
	xTaskCreate(ADC_Task  , NULL, 100, NULL, 2, NULL);
    1ab8:	e1 2c       	mov	r14, r1
    1aba:	f1 2c       	mov	r15, r1
    1abc:	02 e0       	ldi	r16, 0x02	; 2
    1abe:	20 e0       	ldi	r18, 0x00	; 0
    1ac0:	30 e0       	ldi	r19, 0x00	; 0
    1ac2:	44 e6       	ldi	r20, 0x64	; 100
    1ac4:	50 e0       	ldi	r21, 0x00	; 0
    1ac6:	60 e0       	ldi	r22, 0x00	; 0
    1ac8:	70 e0       	ldi	r23, 0x00	; 0
    1aca:	83 ec       	ldi	r24, 0xC3	; 195
    1acc:	9b e0       	ldi	r25, 0x0B	; 11
    1ace:	0e 94 9d 06 	call	0xd3a	; 0xd3a <xTaskCreate>
	xTaskCreate(POT_Task  , NULL, 100, NULL, 3, NULL);
    1ad2:	03 e0       	ldi	r16, 0x03	; 3
    1ad4:	20 e0       	ldi	r18, 0x00	; 0
    1ad6:	30 e0       	ldi	r19, 0x00	; 0
    1ad8:	44 e6       	ldi	r20, 0x64	; 100
    1ada:	50 e0       	ldi	r21, 0x00	; 0
    1adc:	60 e0       	ldi	r22, 0x00	; 0
    1ade:	70 e0       	ldi	r23, 0x00	; 0
    1ae0:	8e ed       	ldi	r24, 0xDE	; 222
    1ae2:	9b e0       	ldi	r25, 0x0B	; 11
    1ae4:	0e 94 9d 06 	call	0xd3a	; 0xd3a <xTaskCreate>
	xTaskCreate(LM35_Task , NULL, 100, NULL, 5, NULL);
    1ae8:	05 e0       	ldi	r16, 0x05	; 5
    1aea:	20 e0       	ldi	r18, 0x00	; 0
    1aec:	30 e0       	ldi	r19, 0x00	; 0
    1aee:	44 e6       	ldi	r20, 0x64	; 100
    1af0:	50 e0       	ldi	r21, 0x00	; 0
    1af2:	60 e0       	ldi	r22, 0x00	; 0
    1af4:	70 e0       	ldi	r23, 0x00	; 0
    1af6:	89 e0       	ldi	r24, 0x09	; 9
    1af8:	9c e0       	ldi	r25, 0x0C	; 12
    1afa:	0e 94 9d 06 	call	0xd3a	; 0xd3a <xTaskCreate>
	xTaskCreate(ActionTask, NULL, 350, NULL, 4, NULL);
    1afe:	04 e0       	ldi	r16, 0x04	; 4
    1b00:	20 e0       	ldi	r18, 0x00	; 0
    1b02:	30 e0       	ldi	r19, 0x00	; 0
    1b04:	4e e5       	ldi	r20, 0x5E	; 94
    1b06:	51 e0       	ldi	r21, 0x01	; 1
    1b08:	60 e0       	ldi	r22, 0x00	; 0
    1b0a:	70 e0       	ldi	r23, 0x00	; 0
    1b0c:	89 e4       	ldi	r24, 0x49	; 73
    1b0e:	9c e0       	ldi	r25, 0x0C	; 12
    1b10:	0e 94 9d 06 	call	0xd3a	; 0xd3a <xTaskCreate>
	xTaskCreate(keypad_task, NULL, 350, NULL, 1, NULL);
    1b14:	01 e0       	ldi	r16, 0x01	; 1
    1b16:	20 e0       	ldi	r18, 0x00	; 0
    1b18:	30 e0       	ldi	r19, 0x00	; 0
    1b1a:	4e e5       	ldi	r20, 0x5E	; 94
    1b1c:	51 e0       	ldi	r21, 0x01	; 1
    1b1e:	60 e0       	ldi	r22, 0x00	; 0
    1b20:	70 e0       	ldi	r23, 0x00	; 0
    1b22:	8c ed       	ldi	r24, 0xDC	; 220
    1b24:	9d e0       	ldi	r25, 0x0D	; 13
    1b26:	0e 94 9d 06 	call	0xd3a	; 0xd3a <xTaskCreate>
	
	/* init the semaphore binary */
	bsADC = xSemaphoreCreateBinary();
    1b2a:	43 e0       	ldi	r20, 0x03	; 3
    1b2c:	60 e0       	ldi	r22, 0x00	; 0
    1b2e:	81 e0       	ldi	r24, 0x01	; 1
    1b30:	0e 94 7d 03 	call	0x6fa	; 0x6fa <xQueueGenericCreate>
    1b34:	90 93 54 07 	sts	0x0754, r25	; 0x800754 <bsADC+0x1>
    1b38:	80 93 53 07 	sts	0x0753, r24	; 0x800753 <bsADC>
	lcd = xSemaphoreCreateBinary();
    1b3c:	43 e0       	ldi	r20, 0x03	; 3
    1b3e:	60 e0       	ldi	r22, 0x00	; 0
    1b40:	81 e0       	ldi	r24, 0x01	; 1
    1b42:	0e 94 7d 03 	call	0x6fa	; 0x6fa <xQueueGenericCreate>
    1b46:	90 93 52 07 	sts	0x0752, r25	; 0x800752 <lcd+0x1>
    1b4a:	80 93 51 07 	sts	0x0751, r24	; 0x800751 <lcd>
	
	/*start the RTOS*/
	vTaskStartScheduler();
    1b4e:	0e 94 f1 06 	call	0xde2	; 0xde2 <vTaskStartScheduler>
    1b52:	ff cf       	rjmp	.-2      	; 0x1b52 <main+0xe4>

00001b54 <check_pass>:
}*/


/* this function used to check the password */
void check_pass(void)
{
    1b54:	cf 93       	push	r28
	uint8 i,y=0;
    1b56:	20 e0       	ldi	r18, 0x00	; 0

	for (i = 0; i < 3; i++)
    1b58:	c0 e0       	ldi	r28, 0x00	; 0
    1b5a:	25 c0       	rjmp	.+74     	; 0x1ba6 <check_pass+0x52>
	{
		if (keypad_pass[i] != password[i]) // if the pass was wrong  
    1b5c:	8c 2f       	mov	r24, r28
    1b5e:	90 e0       	ldi	r25, 0x00	; 0
    1b60:	fc 01       	movw	r30, r24
    1b62:	e9 5a       	subi	r30, 0xA9	; 169
    1b64:	f8 4f       	sbci	r31, 0xF8	; 248
    1b66:	30 81       	ld	r19, Z
    1b68:	fc 01       	movw	r30, r24
    1b6a:	eb 58       	subi	r30, 0x8B	; 139
    1b6c:	ff 4f       	sbci	r31, 0xFF	; 255
    1b6e:	80 81       	ld	r24, Z
    1b70:	38 17       	cp	r19, r24
    1b72:	b9 f0       	breq	.+46     	; 0x1ba2 <check_pass+0x4e>
		{
			flag =0; 
    1b74:	10 92 56 07 	sts	0x0756, r1	; 0x800756 <flag>
			local_counter++; // try 
    1b78:	80 91 55 07 	lds	r24, 0x0755	; 0x800755 <local_counter>
    1b7c:	8f 5f       	subi	r24, 0xFF	; 255
    1b7e:	80 93 55 07 	sts	0x0755, r24	; 0x800755 <local_counter>
				LCD_Clear();
    1b82:	0e 94 82 0b 	call	0x1704	; 0x1704 <LCD_Clear>
			LCD_ChangePOS_XY(0, 0);
    1b86:	60 e0       	ldi	r22, 0x00	; 0
    1b88:	80 e0       	ldi	r24, 0x00	; 0
    1b8a:	0e 94 35 0b 	call	0x166a	; 0x166a <LCD_ChangePOS_XY>
			LCD_sendString("wrong password");
    1b8e:	84 ed       	ldi	r24, 0xD4	; 212
    1b90:	90 e0       	ldi	r25, 0x00	; 0
    1b92:	0e 94 22 0b 	call	0x1644	; 0x1644 <LCD_sendString>
		
	
			y=0;	// reset the counter  
			vTaskDelay(1000);
    1b96:	88 ee       	ldi	r24, 0xE8	; 232
    1b98:	93 e0       	ldi	r25, 0x03	; 3
    1b9a:	0e 94 4d 08 	call	0x109a	; 0x109a <vTaskDelay>
				LCD_Clear();
			LCD_ChangePOS_XY(0, 0);
			LCD_sendString("wrong password");
		
	
			y=0;	// reset the counter  
    1b9e:	20 e0       	ldi	r18, 0x00	; 0
    1ba0:	01 c0       	rjmp	.+2      	; 0x1ba4 <check_pass+0x50>
			vTaskDelay(1000);
		}
		else
		{
			y++; // in every true ++
    1ba2:	2f 5f       	subi	r18, 0xFF	; 255
/* this function used to check the password */
void check_pass(void)
{
	uint8 i,y=0;

	for (i = 0; i < 3; i++)
    1ba4:	cf 5f       	subi	r28, 0xFF	; 255
    1ba6:	c3 30       	cpi	r28, 0x03	; 3
    1ba8:	c8 f2       	brcs	.-78     	; 0x1b5c <check_pass+0x8>
		{
			y++; // in every true ++
		}
	
	}
		if(y==3) // if y = max password 
    1baa:	23 30       	cpi	r18, 0x03	; 3
    1bac:	19 f4       	brne	.+6      	; 0x1bb4 <check_pass+0x60>
		{
			flag = 1; // change the flag to be true
    1bae:	81 e0       	ldi	r24, 0x01	; 1
    1bb0:	80 93 56 07 	sts	0x0756, r24	; 0x800756 <flag>
			//xSemaphoreGive(lcd);

		}

    1bb4:	cf 91       	pop	r28
    1bb6:	08 95       	ret

00001bb8 <keypad_task>:
{
	uint8 static i=0 , max_pass=3, local_result=0;
	//uint8 keypad_button=0;
	uint8 test = 0;
		//vTaskDelete(ActionTask);
		xSemaphoreTake(lcd,portMAX_DELAY);
    1bb8:	6f ef       	ldi	r22, 0xFF	; 255
    1bba:	7f ef       	ldi	r23, 0xFF	; 255
    1bbc:	80 91 51 07 	lds	r24, 0x0751	; 0x800751 <lcd>
    1bc0:	90 91 52 07 	lds	r25, 0x0752	; 0x800752 <lcd+0x1>
    1bc4:	0e 94 39 04 	call	0x872	; 0x872 <xQueueSemaphoreTake>
// this task set password 
void keypad_task(void * pvparameter)
{
	uint8 static i=0 , max_pass=3, local_result=0;
	//uint8 keypad_button=0;
	uint8 test = 0;
    1bc8:	c0 e0       	ldi	r28, 0x00	; 0
		//vTaskDelete(ActionTask);
		xSemaphoreTake(lcd,portMAX_DELAY);
		
		while(1)
		{
			if (test==0) // the test used to scan the pass if the pass right this fun shouldn't run again 
    1bca:	c1 11       	cpse	r28, r1
    1bcc:	39 c0       	rjmp	.+114    	; 0x1c40 <keypad_task+0x88>
			{
				local_result= keypad_scan();
    1bce:	0e 94 7a 0a 	call	0x14f4	; 0x14f4 <keypad_scan>
    1bd2:	80 93 4f 07 	sts	0x074F, r24	; 0x80074f <local_result.2371>
				while(i<max_pass)
    1bd6:	22 c0       	rjmp	.+68     	; 0x1c1c <keypad_task+0x64>
				{
					while(local_result==0) // if return type =0 wait for it to get the value
					{
						local_result= keypad_scan();
    1bd8:	0e 94 7a 0a 	call	0x14f4	; 0x14f4 <keypad_scan>
    1bdc:	80 93 4f 07 	sts	0x074F, r24	; 0x80074f <local_result.2371>
			if (test==0) // the test used to scan the pass if the pass right this fun shouldn't run again 
			{
				local_result= keypad_scan();
				while(i<max_pass)
				{
					while(local_result==0) // if return type =0 wait for it to get the value
    1be0:	90 91 4f 07 	lds	r25, 0x074F	; 0x80074f <local_result.2371>
    1be4:	99 23       	and	r25, r25
    1be6:	c1 f3       	breq	.-16     	; 0x1bd8 <keypad_task+0x20>
					{
						local_result= keypad_scan();
					}
					keypad_pass[i]=local_result;
    1be8:	80 91 4e 07 	lds	r24, 0x074E	; 0x80074e <i.2369>
    1bec:	e8 2f       	mov	r30, r24
    1bee:	f0 e0       	ldi	r31, 0x00	; 0
    1bf0:	e9 5a       	subi	r30, 0xA9	; 169
    1bf2:	f8 4f       	sbci	r31, 0xF8	; 248
    1bf4:	90 83       	st	Z, r25
					LCD_ChangePOS_XY(i,1);
    1bf6:	61 e0       	ldi	r22, 0x01	; 1
    1bf8:	0e 94 35 0b 	call	0x166a	; 0x166a <LCD_ChangePOS_XY>
					LCD_voidWriteNumber(keypad_pass[i]);
    1bfc:	e0 91 4e 07 	lds	r30, 0x074E	; 0x80074e <i.2369>
    1c00:	f0 e0       	ldi	r31, 0x00	; 0
    1c02:	e9 5a       	subi	r30, 0xA9	; 169
    1c04:	f8 4f       	sbci	r31, 0xF8	; 248
    1c06:	80 81       	ld	r24, Z
    1c08:	90 e0       	ldi	r25, 0x00	; 0
    1c0a:	0e 94 86 0b 	call	0x170c	; 0x170c <LCD_voidWriteNumber>
					//LCD_Send_Data('keypad_pass[i]'+0);
					i++;
    1c0e:	80 91 4e 07 	lds	r24, 0x074E	; 0x80074e <i.2369>
    1c12:	8f 5f       	subi	r24, 0xFF	; 255
    1c14:	80 93 4e 07 	sts	0x074E, r24	; 0x80074e <i.2369>
					local_result=0; // reset again to default
    1c18:	10 92 4f 07 	sts	0x074F, r1	; 0x80074f <local_result.2371>
		while(1)
		{
			if (test==0) // the test used to scan the pass if the pass right this fun shouldn't run again 
			{
				local_result= keypad_scan();
				while(i<max_pass)
    1c1c:	80 91 4e 07 	lds	r24, 0x074E	; 0x80074e <i.2369>
    1c20:	83 30       	cpi	r24, 0x03	; 3
    1c22:	f0 f2       	brcs	.-68     	; 0x1be0 <keypad_task+0x28>
					LCD_voidWriteNumber(keypad_pass[i]);
					//LCD_Send_Data('keypad_pass[i]'+0);
					i++;
					local_result=0; // reset again to default
				}
							check_pass();
    1c24:	0e 94 aa 0d 	call	0x1b54	; 0x1b54 <check_pass>

				if (i==3 && flag==1)
    1c28:	80 91 4e 07 	lds	r24, 0x074E	; 0x80074e <i.2369>
    1c2c:	83 30       	cpi	r24, 0x03	; 3
    1c2e:	21 f4       	brne	.+8      	; 0x1c38 <keypad_task+0x80>
    1c30:	80 91 56 07 	lds	r24, 0x0756	; 0x800756 <flag>
    1c34:	81 30       	cpi	r24, 0x01	; 1
    1c36:	19 f0       	breq	.+6      	; 0x1c3e <keypad_task+0x86>
				{
					test=1;
				}
				else
				{
					i=0;
    1c38:	10 92 4e 07 	sts	0x074E, r1	; 0x80074e <i.2369>
    1c3c:	01 c0       	rjmp	.+2      	; 0x1c40 <keypad_task+0x88>
				}
							check_pass();

				if (i==3 && flag==1)
				{
					test=1;
    1c3e:	c1 e0       	ldi	r28, 0x01	; 1
				{
					DIO_get_pin_value(PORTC_RTOS,pin0,LOW)	;
				}
				
			}*/
			vTaskDelay(50);
    1c40:	82 e3       	ldi	r24, 0x32	; 50
    1c42:	90 e0       	ldi	r25, 0x00	; 0
    1c44:	0e 94 4d 08 	call	0x109a	; 0x109a <vTaskDelay>
		}
    1c48:	c0 cf       	rjmp	.-128    	; 0x1bca <keypad_task+0x12>

00001c4a <ADC_init>:
	else
	{
		local_error_state=NULL_POINTER;
	}
	return local_error_state;
}
    1c4a:	87 b1       	in	r24, 0x07	; 7
    1c4c:	80 64       	ori	r24, 0x40	; 64
    1c4e:	87 b9       	out	0x07, r24	; 7
    1c50:	87 b1       	in	r24, 0x07	; 7
    1c52:	8f 77       	andi	r24, 0x7F	; 127
    1c54:	87 b9       	out	0x07, r24	; 7
    1c56:	86 b1       	in	r24, 0x06	; 6
    1c58:	88 7f       	andi	r24, 0xF8	; 248
    1c5a:	86 b9       	out	0x06, r24	; 6
    1c5c:	86 b1       	in	r24, 0x06	; 6
    1c5e:	83 60       	ori	r24, 0x03	; 3
    1c60:	86 b9       	out	0x06, r24	; 6
    1c62:	86 b1       	in	r24, 0x06	; 6
    1c64:	80 68       	ori	r24, 0x80	; 128
    1c66:	86 b9       	out	0x06, r24	; 6
    1c68:	08 95       	ret

00001c6a <ADC_Start_Chain_Conversion_ASYN>:

uint8 ADC_Start_Chain_Conversion_ASYN(Chain_t * Copy_chain)
{
    1c6a:	fc 01       	movw	r30, r24
	uint8 local_errorState= OK;
	
	if((Copy_chain!=NULL)&&(Copy_chain->ChainChannel!=NULL)&&(Copy_chain->ChainResult!=NULL)
    1c6c:	89 2b       	or	r24, r25
    1c6e:	09 f4       	brne	.+2      	; 0x1c72 <ADC_Start_Chain_Conversion_ASYN+0x8>
    1c70:	40 c0       	rjmp	.+128    	; 0x1cf2 <ADC_Start_Chain_Conversion_ASYN+0x88>
    1c72:	80 81       	ld	r24, Z
    1c74:	91 81       	ldd	r25, Z+1	; 0x01
    1c76:	89 2b       	or	r24, r25
    1c78:	f1 f1       	breq	.+124    	; 0x1cf6 <ADC_Start_Chain_Conversion_ASYN+0x8c>
    1c7a:	82 81       	ldd	r24, Z+2	; 0x02
    1c7c:	93 81       	ldd	r25, Z+3	; 0x03
    1c7e:	00 97       	sbiw	r24, 0x00	; 0
    1c80:	e1 f1       	breq	.+120    	; 0x1cfa <ADC_Start_Chain_Conversion_ASYN+0x90>
	&&(Copy_chain->ChainNotificationFunc !=NULL))
    1c82:	25 81       	ldd	r18, Z+5	; 0x05
    1c84:	36 81       	ldd	r19, Z+6	; 0x06
    1c86:	21 15       	cp	r18, r1
    1c88:	31 05       	cpc	r19, r1
    1c8a:	c9 f1       	breq	.+114    	; 0x1cfe <ADC_Start_Chain_Conversion_ASYN+0x94>
	{
		/*check the ADC Busy State*/
		if(ADC_State==empty)
    1c8c:	40 91 64 07 	lds	r20, 0x0764	; 0x800764 <ADC_State>
    1c90:	41 11       	cpse	r20, r1
    1c92:	37 c0       	rjmp	.+110    	; 0x1d02 <ADC_Start_Chain_Conversion_ASYN+0x98>
		{
			/*now ADC is BUSY*/
			ADC_State=busy;
    1c94:	41 e0       	ldi	r20, 0x01	; 1
    1c96:	40 93 64 07 	sts	0x0764, r20	; 0x800764 <ADC_State>
			/*=ISR will come because of chain of conversion */
			ADC_ISR_Source=CHAIN_CONVERSION;
    1c9a:	40 93 70 07 	sts	0x0770, r20	; 0x800770 <ADC_ISR_Source>
			/*initialize the chain globally for (isr)*/
			ADC_ChainChannel=Copy_chain->ChainChannel;
    1c9e:	40 81       	ld	r20, Z
    1ca0:	51 81       	ldd	r21, Z+1	; 0x01
    1ca2:	50 93 61 07 	sts	0x0761, r21	; 0x800761 <ADC_ChainChannel+0x1>
    1ca6:	40 93 60 07 	sts	0x0760, r20	; 0x800760 <ADC_ChainChannel>
			ADC_ConversionResult= Copy_chain->ChainResult;
    1caa:	90 93 66 07 	sts	0x0766, r25	; 0x800766 <ADC_ConversionResult+0x1>
    1cae:	80 93 65 07 	sts	0x0765, r24	; 0x800765 <ADC_ConversionResult>
			ADC_ChainSize = Copy_chain->ChainSize;
    1cb2:	84 81       	ldd	r24, Z+4	; 0x04
    1cb4:	80 93 5e 07 	sts	0x075E, r24	; 0x80075e <ADC_ChainSize>
			ADC_NotificationFunc = Copy_chain->ChainNotificationFunc;
    1cb8:	30 93 63 07 	sts	0x0763, r19	; 0x800763 <ADC_NotificationFunc+0x1>
    1cbc:	20 93 62 07 	sts	0x0762, r18	; 0x800762 <ADC_NotificationFunc>
			
			ADC_ChainIndex=0;
    1cc0:	10 92 5f 07 	sts	0x075F, r1	; 0x80075f <ADC_ChainIndex>
			/*set required channel */
			ADMUX_REG &= ADMUX_MASK;
    1cc4:	87 b1       	in	r24, 0x07	; 7
    1cc6:	80 7e       	andi	r24, 0xE0	; 224
    1cc8:	87 b9       	out	0x07, r24	; 7
			ADMUX_REG |=ADC_ChainChannel[ADC_ChainIndex];
    1cca:	97 b1       	in	r25, 0x07	; 7
    1ccc:	80 91 5f 07 	lds	r24, 0x075F	; 0x80075f <ADC_ChainIndex>
    1cd0:	e0 91 60 07 	lds	r30, 0x0760	; 0x800760 <ADC_ChainChannel>
    1cd4:	f0 91 61 07 	lds	r31, 0x0761	; 0x800761 <ADC_ChainChannel+0x1>
    1cd8:	e8 0f       	add	r30, r24
    1cda:	f1 1d       	adc	r31, r1
    1cdc:	80 81       	ld	r24, Z
    1cde:	89 2b       	or	r24, r25
    1ce0:	87 b9       	out	0x07, r24	; 7
			
			/*start conversion*/
			Set_Bit(ADCSRA_REG,ADSC);
    1ce2:	86 b1       	in	r24, 0x06	; 6
    1ce4:	80 64       	ori	r24, 0x40	; 64
    1ce6:	86 b9       	out	0x06, r24	; 6
			/*enable ADC conversion complete Interrupt*/
			Set_Bit(ADCSRA_REG,ADIE);
    1ce8:	86 b1       	in	r24, 0x06	; 6
    1cea:	88 60       	ori	r24, 0x08	; 8
    1cec:	86 b9       	out	0x06, r24	; 6
	return local_error_state;
}

uint8 ADC_Start_Chain_Conversion_ASYN(Chain_t * Copy_chain)
{
	uint8 local_errorState= OK;
    1cee:	82 e0       	ldi	r24, 0x02	; 2
    1cf0:	08 95       	ret
			local_errorState=busy;
		}
	}
	else
	{
		local_errorState = NULL_POINTER;
    1cf2:	84 e0       	ldi	r24, 0x04	; 4
    1cf4:	08 95       	ret
    1cf6:	84 e0       	ldi	r24, 0x04	; 4
    1cf8:	08 95       	ret
    1cfa:	84 e0       	ldi	r24, 0x04	; 4
    1cfc:	08 95       	ret
    1cfe:	84 e0       	ldi	r24, 0x04	; 4
    1d00:	08 95       	ret
			Set_Bit(ADCSRA_REG,ADIE);
			
		}
		else
		{
			local_errorState=busy;
    1d02:	81 e0       	ldi	r24, 0x01	; 1
	else
	{
		local_errorState = NULL_POINTER;
	}
	return local_errorState;
}
    1d04:	08 95       	ret

00001d06 <__vector_16>:

/*ADC ISR  (Number of ISR -1)----> 17 - 1 = 16 */

void __vector_16 (void)  __attribute__((signal));
void __vector_16(void)
{
    1d06:	1f 92       	push	r1
    1d08:	0f 92       	push	r0
    1d0a:	0f b6       	in	r0, 0x3f	; 63
    1d0c:	0f 92       	push	r0
    1d0e:	11 24       	eor	r1, r1
    1d10:	2f 93       	push	r18
    1d12:	3f 93       	push	r19
    1d14:	4f 93       	push	r20
    1d16:	5f 93       	push	r21
    1d18:	6f 93       	push	r22
    1d1a:	7f 93       	push	r23
    1d1c:	8f 93       	push	r24
    1d1e:	9f 93       	push	r25
    1d20:	af 93       	push	r26
    1d22:	bf 93       	push	r27
    1d24:	ef 93       	push	r30
    1d26:	ff 93       	push	r31
	if(ADC_ISR_Source==SINGLE_CONVERSION)
    1d28:	80 91 70 07 	lds	r24, 0x0770	; 0x800770 <ADC_ISR_Source>
    1d2c:	81 11       	cpse	r24, r1
    1d2e:	15 c0       	rjmp	.+42     	; 0x1d5a <__vector_16+0x54>
	{
		
			//Read the conversion result
			*ADC_ConversionResult=ADC_T;
    1d30:	e0 91 65 07 	lds	r30, 0x0765	; 0x800765 <ADC_ConversionResult>
    1d34:	f0 91 66 07 	lds	r31, 0x0766	; 0x800766 <ADC_ConversionResult+0x1>
    1d38:	84 b1       	in	r24, 0x04	; 4
    1d3a:	95 b1       	in	r25, 0x05	; 5
    1d3c:	91 83       	std	Z+1, r25	; 0x01
    1d3e:	80 83       	st	Z, r24
			//release the ADC busy State ,ADC is now empty
			ADC_State=empty;
    1d40:	10 92 64 07 	sts	0x0764, r1	; 0x800764 <ADC_State>
			//Disable the ADC conversion complete interrupt
			Clear_Bit(ADCSRA_REG,ADIE);
    1d44:	86 b1       	in	r24, 0x06	; 6
    1d46:	87 7f       	andi	r24, 0xF7	; 247
    1d48:	86 b9       	out	0x06, r24	; 6
			//Invoke the callback notification function
			if(ADC_NotificationFunc!=NULL)
    1d4a:	e0 91 62 07 	lds	r30, 0x0762	; 0x800762 <ADC_NotificationFunc>
    1d4e:	f0 91 63 07 	lds	r31, 0x0763	; 0x800763 <ADC_NotificationFunc+0x1>
    1d52:	30 97       	sbiw	r30, 0x00	; 0
    1d54:	c1 f1       	breq	.+112    	; 0x1dc6 <__vector_16+0xc0>
			{
				ADC_NotificationFunc();
    1d56:	09 95       	icall
    1d58:	36 c0       	rjmp	.+108    	; 0x1dc6 <__vector_16+0xc0>
			}	
	}
	else // ISR source is chain conversion
	{
		//read the conversion result
		ADC_ConversionResult[ADC_ChainIndex]=ADC_T;
    1d5a:	80 91 5f 07 	lds	r24, 0x075F	; 0x80075f <ADC_ChainIndex>
    1d5e:	e8 2f       	mov	r30, r24
    1d60:	f0 e0       	ldi	r31, 0x00	; 0
    1d62:	ee 0f       	add	r30, r30
    1d64:	ff 1f       	adc	r31, r31
    1d66:	20 91 65 07 	lds	r18, 0x0765	; 0x800765 <ADC_ConversionResult>
    1d6a:	30 91 66 07 	lds	r19, 0x0766	; 0x800766 <ADC_ConversionResult+0x1>
    1d6e:	e2 0f       	add	r30, r18
    1d70:	f3 1f       	adc	r31, r19
    1d72:	24 b1       	in	r18, 0x04	; 4
    1d74:	35 b1       	in	r19, 0x05	; 5
    1d76:	31 83       	std	Z+1, r19	; 0x01
    1d78:	20 83       	st	Z, r18
		
		// inc the index to get the next channel result
		ADC_ChainIndex++;
    1d7a:	8f 5f       	subi	r24, 0xFF	; 255
    1d7c:	80 93 5f 07 	sts	0x075F, r24	; 0x80075f <ADC_ChainIndex>
		
		//check if the ADC chain == index : its finished the chain
		if(ADC_ChainIndex==ADC_ChainSize)
    1d80:	90 91 5e 07 	lds	r25, 0x075E	; 0x80075e <ADC_ChainSize>
    1d84:	89 13       	cpse	r24, r25
    1d86:	0d c0       	rjmp	.+26     	; 0x1da2 <__vector_16+0x9c>
		{
			//chain is finished & adc is empty
			ADC_State=empty;
    1d88:	10 92 64 07 	sts	0x0764, r1	; 0x800764 <ADC_State>
			//Disable the ADC conversion complete interrupt
			Clear_Bit(ADCSRA_REG,ADIE);
    1d8c:	86 b1       	in	r24, 0x06	; 6
    1d8e:	87 7f       	andi	r24, 0xF7	; 247
    1d90:	86 b9       	out	0x06, r24	; 6
			//Invoke the callback notification function
			if(ADC_NotificationFunc!=NULL)
    1d92:	e0 91 62 07 	lds	r30, 0x0762	; 0x800762 <ADC_NotificationFunc>
    1d96:	f0 91 63 07 	lds	r31, 0x0763	; 0x800763 <ADC_NotificationFunc+0x1>
    1d9a:	30 97       	sbiw	r30, 0x00	; 0
    1d9c:	a1 f0       	breq	.+40     	; 0x1dc6 <__vector_16+0xc0>
			{
				ADC_NotificationFunc();
    1d9e:	09 95       	icall
    1da0:	12 c0       	rjmp	.+36     	; 0x1dc6 <__vector_16+0xc0>
		}
		else
		{
			//chain isn't finished
			//set required channel
			ADMUX_REG&= ADMUX_MASK;
    1da2:	87 b1       	in	r24, 0x07	; 7
    1da4:	80 7e       	andi	r24, 0xE0	; 224
    1da6:	87 b9       	out	0x07, r24	; 7
			ADMUX_REG|=ADC_ChainChannel[ADC_ChainIndex];
    1da8:	97 b1       	in	r25, 0x07	; 7
    1daa:	80 91 5f 07 	lds	r24, 0x075F	; 0x80075f <ADC_ChainIndex>
    1dae:	e0 91 60 07 	lds	r30, 0x0760	; 0x800760 <ADC_ChainChannel>
    1db2:	f0 91 61 07 	lds	r31, 0x0761	; 0x800761 <ADC_ChainChannel+0x1>
    1db6:	e8 0f       	add	r30, r24
    1db8:	f1 1d       	adc	r31, r1
    1dba:	80 81       	ld	r24, Z
    1dbc:	89 2b       	or	r24, r25
    1dbe:	87 b9       	out	0x07, r24	; 7
			//Start conversion
			Set_Bit(ADCSRA_REG,ADSC);
    1dc0:	86 b1       	in	r24, 0x06	; 6
    1dc2:	80 64       	ori	r24, 0x40	; 64
    1dc4:	86 b9       	out	0x06, r24	; 6
		}
	}
}
    1dc6:	ff 91       	pop	r31
    1dc8:	ef 91       	pop	r30
    1dca:	bf 91       	pop	r27
    1dcc:	af 91       	pop	r26
    1dce:	9f 91       	pop	r25
    1dd0:	8f 91       	pop	r24
    1dd2:	7f 91       	pop	r23
    1dd4:	6f 91       	pop	r22
    1dd6:	5f 91       	pop	r21
    1dd8:	4f 91       	pop	r20
    1dda:	3f 91       	pop	r19
    1ddc:	2f 91       	pop	r18
    1dde:	0f 90       	pop	r0
    1de0:	0f be       	out	0x3f, r0	; 63
    1de2:	0f 90       	pop	r0
    1de4:	1f 90       	pop	r1
    1de6:	18 95       	reti

00001de8 <DIO_set_pin_direction>:
		switch(port_id)
		{
			case PORTA: *val= Get_Bit(PINA_REG,pin_id)  ;    break;
			case PORTB: *val= Get_Bit(PINB_REG,pin_id)  ;    break;
			case PORTC: *val= Get_Bit(PINC_REG,pin_id)  ;    break;
			case PORTD: *val= Get_Bit(PIND_REG,pin_id)  ;    break;
    1de8:	68 30       	cpi	r22, 0x08	; 8
    1dea:	08 f0       	brcs	.+2      	; 0x1dee <DIO_set_pin_direction+0x6>
    1dec:	75 c0       	rjmp	.+234    	; 0x1ed8 <DIO_set_pin_direction+0xf0>
    1dee:	84 30       	cpi	r24, 0x04	; 4
    1df0:	08 f0       	brcs	.+2      	; 0x1df4 <DIO_set_pin_direction+0xc>
    1df2:	72 c0       	rjmp	.+228    	; 0x1ed8 <DIO_set_pin_direction+0xf0>
    1df4:	41 30       	cpi	r20, 0x01	; 1
    1df6:	b9 f5       	brne	.+110    	; 0x1e66 <DIO_set_pin_direction+0x7e>
    1df8:	81 30       	cpi	r24, 0x01	; 1
    1dfa:	91 f0       	breq	.+36     	; 0x1e20 <DIO_set_pin_direction+0x38>
    1dfc:	28 f0       	brcs	.+10     	; 0x1e08 <DIO_set_pin_direction+0x20>
    1dfe:	82 30       	cpi	r24, 0x02	; 2
    1e00:	d9 f0       	breq	.+54     	; 0x1e38 <DIO_set_pin_direction+0x50>
    1e02:	83 30       	cpi	r24, 0x03	; 3
    1e04:	29 f1       	breq	.+74     	; 0x1e50 <DIO_set_pin_direction+0x68>
    1e06:	2f c0       	rjmp	.+94     	; 0x1e66 <DIO_set_pin_direction+0x7e>
    1e08:	9a b3       	in	r25, 0x1a	; 26
    1e0a:	21 e0       	ldi	r18, 0x01	; 1
    1e0c:	30 e0       	ldi	r19, 0x00	; 0
    1e0e:	06 2e       	mov	r0, r22
    1e10:	02 c0       	rjmp	.+4      	; 0x1e16 <DIO_set_pin_direction+0x2e>
    1e12:	22 0f       	add	r18, r18
    1e14:	33 1f       	adc	r19, r19
    1e16:	0a 94       	dec	r0
    1e18:	e2 f7       	brpl	.-8      	; 0x1e12 <DIO_set_pin_direction+0x2a>
    1e1a:	29 2b       	or	r18, r25
    1e1c:	2a bb       	out	0x1a, r18	; 26
    1e1e:	23 c0       	rjmp	.+70     	; 0x1e66 <DIO_set_pin_direction+0x7e>
    1e20:	97 b3       	in	r25, 0x17	; 23
    1e22:	21 e0       	ldi	r18, 0x01	; 1
    1e24:	30 e0       	ldi	r19, 0x00	; 0
    1e26:	06 2e       	mov	r0, r22
    1e28:	02 c0       	rjmp	.+4      	; 0x1e2e <DIO_set_pin_direction+0x46>
    1e2a:	22 0f       	add	r18, r18
    1e2c:	33 1f       	adc	r19, r19
    1e2e:	0a 94       	dec	r0
    1e30:	e2 f7       	brpl	.-8      	; 0x1e2a <DIO_set_pin_direction+0x42>
    1e32:	29 2b       	or	r18, r25
    1e34:	27 bb       	out	0x17, r18	; 23
    1e36:	17 c0       	rjmp	.+46     	; 0x1e66 <DIO_set_pin_direction+0x7e>
    1e38:	94 b3       	in	r25, 0x14	; 20
    1e3a:	21 e0       	ldi	r18, 0x01	; 1
    1e3c:	30 e0       	ldi	r19, 0x00	; 0
    1e3e:	06 2e       	mov	r0, r22
    1e40:	02 c0       	rjmp	.+4      	; 0x1e46 <DIO_set_pin_direction+0x5e>
    1e42:	22 0f       	add	r18, r18
    1e44:	33 1f       	adc	r19, r19
    1e46:	0a 94       	dec	r0
    1e48:	e2 f7       	brpl	.-8      	; 0x1e42 <DIO_set_pin_direction+0x5a>
    1e4a:	29 2b       	or	r18, r25
    1e4c:	24 bb       	out	0x14, r18	; 20
    1e4e:	0b c0       	rjmp	.+22     	; 0x1e66 <DIO_set_pin_direction+0x7e>
    1e50:	91 b3       	in	r25, 0x11	; 17
    1e52:	21 e0       	ldi	r18, 0x01	; 1
    1e54:	30 e0       	ldi	r19, 0x00	; 0
    1e56:	06 2e       	mov	r0, r22
    1e58:	02 c0       	rjmp	.+4      	; 0x1e5e <DIO_set_pin_direction+0x76>
    1e5a:	22 0f       	add	r18, r18
    1e5c:	33 1f       	adc	r19, r19
    1e5e:	0a 94       	dec	r0
    1e60:	e2 f7       	brpl	.-8      	; 0x1e5a <DIO_set_pin_direction+0x72>
    1e62:	29 2b       	or	r18, r25
    1e64:	21 bb       	out	0x11, r18	; 17
    1e66:	41 11       	cpse	r20, r1
    1e68:	37 c0       	rjmp	.+110    	; 0x1ed8 <DIO_set_pin_direction+0xf0>
    1e6a:	81 30       	cpi	r24, 0x01	; 1
    1e6c:	91 f0       	breq	.+36     	; 0x1e92 <DIO_set_pin_direction+0xaa>
    1e6e:	28 f0       	brcs	.+10     	; 0x1e7a <DIO_set_pin_direction+0x92>
    1e70:	82 30       	cpi	r24, 0x02	; 2
    1e72:	d9 f0       	breq	.+54     	; 0x1eaa <DIO_set_pin_direction+0xc2>
    1e74:	83 30       	cpi	r24, 0x03	; 3
    1e76:	29 f1       	breq	.+74     	; 0x1ec2 <DIO_set_pin_direction+0xda>
    1e78:	08 95       	ret
    1e7a:	2a b3       	in	r18, 0x1a	; 26
    1e7c:	81 e0       	ldi	r24, 0x01	; 1
    1e7e:	90 e0       	ldi	r25, 0x00	; 0
    1e80:	02 c0       	rjmp	.+4      	; 0x1e86 <DIO_set_pin_direction+0x9e>
    1e82:	88 0f       	add	r24, r24
    1e84:	99 1f       	adc	r25, r25
    1e86:	6a 95       	dec	r22
    1e88:	e2 f7       	brpl	.-8      	; 0x1e82 <DIO_set_pin_direction+0x9a>
    1e8a:	80 95       	com	r24
    1e8c:	82 23       	and	r24, r18
    1e8e:	8a bb       	out	0x1a, r24	; 26
    1e90:	08 95       	ret
    1e92:	27 b3       	in	r18, 0x17	; 23
    1e94:	81 e0       	ldi	r24, 0x01	; 1
    1e96:	90 e0       	ldi	r25, 0x00	; 0
    1e98:	02 c0       	rjmp	.+4      	; 0x1e9e <DIO_set_pin_direction+0xb6>
    1e9a:	88 0f       	add	r24, r24
    1e9c:	99 1f       	adc	r25, r25
    1e9e:	6a 95       	dec	r22
    1ea0:	e2 f7       	brpl	.-8      	; 0x1e9a <DIO_set_pin_direction+0xb2>
    1ea2:	80 95       	com	r24
    1ea4:	82 23       	and	r24, r18
    1ea6:	87 bb       	out	0x17, r24	; 23
    1ea8:	08 95       	ret
    1eaa:	24 b3       	in	r18, 0x14	; 20
    1eac:	81 e0       	ldi	r24, 0x01	; 1
    1eae:	90 e0       	ldi	r25, 0x00	; 0
    1eb0:	02 c0       	rjmp	.+4      	; 0x1eb6 <DIO_set_pin_direction+0xce>
    1eb2:	88 0f       	add	r24, r24
    1eb4:	99 1f       	adc	r25, r25
    1eb6:	6a 95       	dec	r22
    1eb8:	e2 f7       	brpl	.-8      	; 0x1eb2 <DIO_set_pin_direction+0xca>
    1eba:	80 95       	com	r24
    1ebc:	82 23       	and	r24, r18
    1ebe:	84 bb       	out	0x14, r24	; 20
    1ec0:	08 95       	ret
    1ec2:	21 b3       	in	r18, 0x11	; 17
    1ec4:	81 e0       	ldi	r24, 0x01	; 1
    1ec6:	90 e0       	ldi	r25, 0x00	; 0
    1ec8:	02 c0       	rjmp	.+4      	; 0x1ece <DIO_set_pin_direction+0xe6>
    1eca:	88 0f       	add	r24, r24
    1ecc:	99 1f       	adc	r25, r25
    1ece:	6a 95       	dec	r22
    1ed0:	e2 f7       	brpl	.-8      	; 0x1eca <DIO_set_pin_direction+0xe2>
    1ed2:	80 95       	com	r24
    1ed4:	82 23       	and	r24, r18
    1ed6:	81 bb       	out	0x11, r24	; 17
    1ed8:	08 95       	ret

00001eda <DIO_set_pin_value>:
    1eda:	84 30       	cpi	r24, 0x04	; 4
    1edc:	08 f0       	brcs	.+2      	; 0x1ee0 <DIO_set_pin_value+0x6>
    1ede:	75 c0       	rjmp	.+234    	; 0x1fca <DIO_set_pin_value+0xf0>
    1ee0:	68 30       	cpi	r22, 0x08	; 8
    1ee2:	08 f0       	brcs	.+2      	; 0x1ee6 <DIO_set_pin_value+0xc>
    1ee4:	72 c0       	rjmp	.+228    	; 0x1fca <DIO_set_pin_value+0xf0>
    1ee6:	41 11       	cpse	r20, r1
    1ee8:	3b c0       	rjmp	.+118    	; 0x1f60 <DIO_set_pin_value+0x86>
    1eea:	81 30       	cpi	r24, 0x01	; 1
    1eec:	99 f0       	breq	.+38     	; 0x1f14 <DIO_set_pin_value+0x3a>
    1eee:	28 f0       	brcs	.+10     	; 0x1efa <DIO_set_pin_value+0x20>
    1ef0:	82 30       	cpi	r24, 0x02	; 2
    1ef2:	e9 f0       	breq	.+58     	; 0x1f2e <DIO_set_pin_value+0x54>
    1ef4:	83 30       	cpi	r24, 0x03	; 3
    1ef6:	41 f1       	breq	.+80     	; 0x1f48 <DIO_set_pin_value+0x6e>
    1ef8:	33 c0       	rjmp	.+102    	; 0x1f60 <DIO_set_pin_value+0x86>
    1efa:	9b b3       	in	r25, 0x1b	; 27
    1efc:	21 e0       	ldi	r18, 0x01	; 1
    1efe:	30 e0       	ldi	r19, 0x00	; 0
    1f00:	06 2e       	mov	r0, r22
    1f02:	02 c0       	rjmp	.+4      	; 0x1f08 <DIO_set_pin_value+0x2e>
    1f04:	22 0f       	add	r18, r18
    1f06:	33 1f       	adc	r19, r19
    1f08:	0a 94       	dec	r0
    1f0a:	e2 f7       	brpl	.-8      	; 0x1f04 <DIO_set_pin_value+0x2a>
    1f0c:	20 95       	com	r18
    1f0e:	29 23       	and	r18, r25
    1f10:	2b bb       	out	0x1b, r18	; 27
    1f12:	26 c0       	rjmp	.+76     	; 0x1f60 <DIO_set_pin_value+0x86>
    1f14:	98 b3       	in	r25, 0x18	; 24
    1f16:	21 e0       	ldi	r18, 0x01	; 1
    1f18:	30 e0       	ldi	r19, 0x00	; 0
    1f1a:	06 2e       	mov	r0, r22
    1f1c:	02 c0       	rjmp	.+4      	; 0x1f22 <DIO_set_pin_value+0x48>
    1f1e:	22 0f       	add	r18, r18
    1f20:	33 1f       	adc	r19, r19
    1f22:	0a 94       	dec	r0
    1f24:	e2 f7       	brpl	.-8      	; 0x1f1e <DIO_set_pin_value+0x44>
    1f26:	20 95       	com	r18
    1f28:	29 23       	and	r18, r25
    1f2a:	28 bb       	out	0x18, r18	; 24
    1f2c:	19 c0       	rjmp	.+50     	; 0x1f60 <DIO_set_pin_value+0x86>
    1f2e:	95 b3       	in	r25, 0x15	; 21
    1f30:	21 e0       	ldi	r18, 0x01	; 1
    1f32:	30 e0       	ldi	r19, 0x00	; 0
    1f34:	06 2e       	mov	r0, r22
    1f36:	02 c0       	rjmp	.+4      	; 0x1f3c <DIO_set_pin_value+0x62>
    1f38:	22 0f       	add	r18, r18
    1f3a:	33 1f       	adc	r19, r19
    1f3c:	0a 94       	dec	r0
    1f3e:	e2 f7       	brpl	.-8      	; 0x1f38 <DIO_set_pin_value+0x5e>
    1f40:	20 95       	com	r18
    1f42:	29 23       	and	r18, r25
    1f44:	25 bb       	out	0x15, r18	; 21
    1f46:	0c c0       	rjmp	.+24     	; 0x1f60 <DIO_set_pin_value+0x86>
    1f48:	92 b3       	in	r25, 0x12	; 18
    1f4a:	21 e0       	ldi	r18, 0x01	; 1
    1f4c:	30 e0       	ldi	r19, 0x00	; 0
    1f4e:	06 2e       	mov	r0, r22
    1f50:	02 c0       	rjmp	.+4      	; 0x1f56 <DIO_set_pin_value+0x7c>
    1f52:	22 0f       	add	r18, r18
    1f54:	33 1f       	adc	r19, r19
    1f56:	0a 94       	dec	r0
    1f58:	e2 f7       	brpl	.-8      	; 0x1f52 <DIO_set_pin_value+0x78>
    1f5a:	20 95       	com	r18
    1f5c:	29 23       	and	r18, r25
    1f5e:	22 bb       	out	0x12, r18	; 18
    1f60:	41 30       	cpi	r20, 0x01	; 1
    1f62:	99 f5       	brne	.+102    	; 0x1fca <DIO_set_pin_value+0xf0>
    1f64:	81 30       	cpi	r24, 0x01	; 1
    1f66:	89 f0       	breq	.+34     	; 0x1f8a <DIO_set_pin_value+0xb0>
    1f68:	28 f0       	brcs	.+10     	; 0x1f74 <DIO_set_pin_value+0x9a>
    1f6a:	82 30       	cpi	r24, 0x02	; 2
    1f6c:	c9 f0       	breq	.+50     	; 0x1fa0 <DIO_set_pin_value+0xc6>
    1f6e:	83 30       	cpi	r24, 0x03	; 3
    1f70:	11 f1       	breq	.+68     	; 0x1fb6 <DIO_set_pin_value+0xdc>
    1f72:	08 95       	ret
    1f74:	2b b3       	in	r18, 0x1b	; 27
    1f76:	81 e0       	ldi	r24, 0x01	; 1
    1f78:	90 e0       	ldi	r25, 0x00	; 0
    1f7a:	02 c0       	rjmp	.+4      	; 0x1f80 <DIO_set_pin_value+0xa6>
    1f7c:	88 0f       	add	r24, r24
    1f7e:	99 1f       	adc	r25, r25
    1f80:	6a 95       	dec	r22
    1f82:	e2 f7       	brpl	.-8      	; 0x1f7c <DIO_set_pin_value+0xa2>
    1f84:	82 2b       	or	r24, r18
    1f86:	8b bb       	out	0x1b, r24	; 27
    1f88:	08 95       	ret
    1f8a:	28 b3       	in	r18, 0x18	; 24
    1f8c:	81 e0       	ldi	r24, 0x01	; 1
    1f8e:	90 e0       	ldi	r25, 0x00	; 0
    1f90:	02 c0       	rjmp	.+4      	; 0x1f96 <DIO_set_pin_value+0xbc>
    1f92:	88 0f       	add	r24, r24
    1f94:	99 1f       	adc	r25, r25
    1f96:	6a 95       	dec	r22
    1f98:	e2 f7       	brpl	.-8      	; 0x1f92 <DIO_set_pin_value+0xb8>
    1f9a:	82 2b       	or	r24, r18
    1f9c:	88 bb       	out	0x18, r24	; 24
    1f9e:	08 95       	ret
    1fa0:	25 b3       	in	r18, 0x15	; 21
    1fa2:	81 e0       	ldi	r24, 0x01	; 1
    1fa4:	90 e0       	ldi	r25, 0x00	; 0
    1fa6:	02 c0       	rjmp	.+4      	; 0x1fac <DIO_set_pin_value+0xd2>
    1fa8:	88 0f       	add	r24, r24
    1faa:	99 1f       	adc	r25, r25
    1fac:	6a 95       	dec	r22
    1fae:	e2 f7       	brpl	.-8      	; 0x1fa8 <DIO_set_pin_value+0xce>
    1fb0:	82 2b       	or	r24, r18
    1fb2:	85 bb       	out	0x15, r24	; 21
    1fb4:	08 95       	ret
    1fb6:	22 b3       	in	r18, 0x12	; 18
    1fb8:	81 e0       	ldi	r24, 0x01	; 1
    1fba:	90 e0       	ldi	r25, 0x00	; 0
    1fbc:	02 c0       	rjmp	.+4      	; 0x1fc2 <DIO_set_pin_value+0xe8>
    1fbe:	88 0f       	add	r24, r24
    1fc0:	99 1f       	adc	r25, r25
    1fc2:	6a 95       	dec	r22
    1fc4:	e2 f7       	brpl	.-8      	; 0x1fbe <DIO_set_pin_value+0xe4>
    1fc6:	82 2b       	or	r24, r18
    1fc8:	82 bb       	out	0x12, r24	; 18
    1fca:	08 95       	ret

00001fcc <DIO_set_port_char>:
}


void DIO_set_port_char(DIO_PORT_ID port_id,EN_Dio_Value val)
{
	if(port_id<=PORTD)
    1fcc:	84 30       	cpi	r24, 0x04	; 4
    1fce:	78 f4       	brcc	.+30     	; 0x1fee <DIO_set_port_char+0x22>
	{
			switch(port_id)
    1fd0:	81 30       	cpi	r24, 0x01	; 1
    1fd2:	41 f0       	breq	.+16     	; 0x1fe4 <DIO_set_port_char+0x18>
    1fd4:	28 f0       	brcs	.+10     	; 0x1fe0 <DIO_set_port_char+0x14>
    1fd6:	82 30       	cpi	r24, 0x02	; 2
    1fd8:	39 f0       	breq	.+14     	; 0x1fe8 <DIO_set_port_char+0x1c>
    1fda:	83 30       	cpi	r24, 0x03	; 3
    1fdc:	39 f0       	breq	.+14     	; 0x1fec <DIO_set_port_char+0x20>
    1fde:	08 95       	ret
			{
				case PORTA: PORTA_REG=val         ;    break;
    1fe0:	6b bb       	out	0x1b, r22	; 27
    1fe2:	08 95       	ret
				case PORTB: PORTB_REG=val         ;    break;
    1fe4:	68 bb       	out	0x18, r22	; 24
    1fe6:	08 95       	ret
				case PORTC: PORTC_REG=val         ;    break;
    1fe8:	65 bb       	out	0x15, r22	; 21
    1fea:	08 95       	ret
				case PORTD: PORTD_REG=val         ;    break;
    1fec:	62 bb       	out	0x12, r22	; 18
    1fee:	08 95       	ret

00001ff0 <__vector_11>:
}

/*timer0 overflow ISR*/
void __vector_11 (void) __attribute__((signal));
void __vector_11 (void)
{
    1ff0:	1f 92       	push	r1
    1ff2:	0f 92       	push	r0
    1ff4:	0f b6       	in	r0, 0x3f	; 63
    1ff6:	0f 92       	push	r0
    1ff8:	11 24       	eor	r1, r1
    1ffa:	2f 93       	push	r18
    1ffc:	3f 93       	push	r19
    1ffe:	4f 93       	push	r20
    2000:	5f 93       	push	r21
    2002:	6f 93       	push	r22
    2004:	7f 93       	push	r23
    2006:	8f 93       	push	r24
    2008:	9f 93       	push	r25
    200a:	af 93       	push	r26
    200c:	bf 93       	push	r27
    200e:	ef 93       	push	r30
    2010:	ff 93       	push	r31
	if(timer0_pCallbackFunc!=NULL)
    2012:	e0 91 67 07 	lds	r30, 0x0767	; 0x800767 <timer0_pCallbackFunc>
    2016:	f0 91 68 07 	lds	r31, 0x0768	; 0x800768 <timer0_pCallbackFunc+0x1>
    201a:	30 97       	sbiw	r30, 0x00	; 0
    201c:	09 f0       	breq	.+2      	; 0x2020 <__vector_11+0x30>
	{
		timer0_pCallbackFunc();
    201e:	09 95       	icall
	else
	{
		/*do nothing*/
	}
	
}
    2020:	ff 91       	pop	r31
    2022:	ef 91       	pop	r30
    2024:	bf 91       	pop	r27
    2026:	af 91       	pop	r26
    2028:	9f 91       	pop	r25
    202a:	8f 91       	pop	r24
    202c:	7f 91       	pop	r23
    202e:	6f 91       	pop	r22
    2030:	5f 91       	pop	r21
    2032:	4f 91       	pop	r20
    2034:	3f 91       	pop	r19
    2036:	2f 91       	pop	r18
    2038:	0f 90       	pop	r0
    203a:	0f be       	out	0x3f, r0	; 63
    203c:	0f 90       	pop	r0
    203e:	1f 90       	pop	r1
    2040:	18 95       	reti

00002042 <__udivmodhi4>:
    2042:	aa 1b       	sub	r26, r26
    2044:	bb 1b       	sub	r27, r27
    2046:	51 e1       	ldi	r21, 0x11	; 17
    2048:	07 c0       	rjmp	.+14     	; 0x2058 <__udivmodhi4_ep>

0000204a <__udivmodhi4_loop>:
    204a:	aa 1f       	adc	r26, r26
    204c:	bb 1f       	adc	r27, r27
    204e:	a6 17       	cp	r26, r22
    2050:	b7 07       	cpc	r27, r23
    2052:	10 f0       	brcs	.+4      	; 0x2058 <__udivmodhi4_ep>
    2054:	a6 1b       	sub	r26, r22
    2056:	b7 0b       	sbc	r27, r23

00002058 <__udivmodhi4_ep>:
    2058:	88 1f       	adc	r24, r24
    205a:	99 1f       	adc	r25, r25
    205c:	5a 95       	dec	r21
    205e:	a9 f7       	brne	.-22     	; 0x204a <__udivmodhi4_loop>
    2060:	80 95       	com	r24
    2062:	90 95       	com	r25
    2064:	bc 01       	movw	r22, r24
    2066:	cd 01       	movw	r24, r26
    2068:	08 95       	ret

0000206a <__udivmodsi4>:
    206a:	a1 e2       	ldi	r26, 0x21	; 33
    206c:	1a 2e       	mov	r1, r26
    206e:	aa 1b       	sub	r26, r26
    2070:	bb 1b       	sub	r27, r27
    2072:	fd 01       	movw	r30, r26
    2074:	0d c0       	rjmp	.+26     	; 0x2090 <__udivmodsi4_ep>

00002076 <__udivmodsi4_loop>:
    2076:	aa 1f       	adc	r26, r26
    2078:	bb 1f       	adc	r27, r27
    207a:	ee 1f       	adc	r30, r30
    207c:	ff 1f       	adc	r31, r31
    207e:	a2 17       	cp	r26, r18
    2080:	b3 07       	cpc	r27, r19
    2082:	e4 07       	cpc	r30, r20
    2084:	f5 07       	cpc	r31, r21
    2086:	20 f0       	brcs	.+8      	; 0x2090 <__udivmodsi4_ep>
    2088:	a2 1b       	sub	r26, r18
    208a:	b3 0b       	sbc	r27, r19
    208c:	e4 0b       	sbc	r30, r20
    208e:	f5 0b       	sbc	r31, r21

00002090 <__udivmodsi4_ep>:
    2090:	66 1f       	adc	r22, r22
    2092:	77 1f       	adc	r23, r23
    2094:	88 1f       	adc	r24, r24
    2096:	99 1f       	adc	r25, r25
    2098:	1a 94       	dec	r1
    209a:	69 f7       	brne	.-38     	; 0x2076 <__udivmodsi4_loop>
    209c:	60 95       	com	r22
    209e:	70 95       	com	r23
    20a0:	80 95       	com	r24
    20a2:	90 95       	com	r25
    20a4:	9b 01       	movw	r18, r22
    20a6:	ac 01       	movw	r20, r24
    20a8:	bd 01       	movw	r22, r26
    20aa:	cf 01       	movw	r24, r30
    20ac:	08 95       	ret

000020ae <__umulhisi3>:
    20ae:	a2 9f       	mul	r26, r18
    20b0:	b0 01       	movw	r22, r0
    20b2:	b3 9f       	mul	r27, r19
    20b4:	c0 01       	movw	r24, r0
    20b6:	a3 9f       	mul	r26, r19
    20b8:	70 0d       	add	r23, r0
    20ba:	81 1d       	adc	r24, r1
    20bc:	11 24       	eor	r1, r1
    20be:	91 1d       	adc	r25, r1
    20c0:	b2 9f       	mul	r27, r18
    20c2:	70 0d       	add	r23, r0
    20c4:	81 1d       	adc	r24, r1
    20c6:	11 24       	eor	r1, r1
    20c8:	91 1d       	adc	r25, r1
    20ca:	08 95       	ret

000020cc <memcpy>:
    20cc:	fb 01       	movw	r30, r22
    20ce:	dc 01       	movw	r26, r24
    20d0:	02 c0       	rjmp	.+4      	; 0x20d6 <memcpy+0xa>
    20d2:	01 90       	ld	r0, Z+
    20d4:	0d 92       	st	X+, r0
    20d6:	41 50       	subi	r20, 0x01	; 1
    20d8:	50 40       	sbci	r21, 0x00	; 0
    20da:	d8 f7       	brcc	.-10     	; 0x20d2 <memcpy+0x6>
    20dc:	08 95       	ret

000020de <_exit>:
    20de:	f8 94       	cli

000020e0 <__stop_program>:
    20e0:	ff cf       	rjmp	.-2      	; 0x20e0 <__stop_program>
